<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">Chapter 13. EPL Reference: Data Windows</title><link rel="stylesheet" href="css/espertech.css" type="text/css"/><meta xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL-NS Stylesheets V1.74.0"/><meta xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" http-equiv="Content-Type" content="text/html; charset=UTF-8"/><link rel="home" href="index.html" title="Esper Reference"/><link rel="up" href="index.html" title="Esper Reference"/><link rel="prev" href="datetimereference.html" title="Chapter 12. EPL Reference: Date-Time Methods"/><link rel="next" href="api.html" title="Chapter 14. API Reference"/></head><body><p xmlns:d="http://docbook.org/ns/docbook" id="title"><a href="http://www.espertech.com" class="site_href"><strong>www.espertech.com</strong></a><a href="http://www.espertech.com/esper/documentation.php" class="doc_href"><strong>Documentation</strong></a></p><ul xmlns:d="http://docbook.org/ns/docbook" class="docnav"><li class="previous"><a accesskey="p" href="datetimereference.html"><strong>Prev</strong></a></li><li class="next"><a accesskey="n" href="api.html"><strong>Next</strong></a></li></ul><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="epl-views"/>Chapter 13. EPL Reference: Data Windows</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="epl-views.html#view-parameters">13.1. A Note on Data Window Name and Parameters</a></span></dt><dt><span class="sect1"><a href="epl-views.html#view-batchwindows">13.2. A Note on Batch Windows</a></span></dt><dt><span class="sect1"><a href="epl-views.html#win-views">13.3. Data Windows</a></span></dt><dd><dl><dt><span class="sect2"><a href="epl-views.html#view-win-length">13.3.1. Length Window (length or win:length)</a></span></dt><dt><span class="sect2"><a href="epl-views.html#view-win-length-batch">13.3.2. Length Batch Window (length_batch or win:length_batch)</a></span></dt><dt><span class="sect2"><a href="epl-views.html#view-win-time">13.3.3. Time Window (time or win:time)</a></span></dt><dt><span class="sect2"><a href="epl-views.html#view-win-ext_time">13.3.4. Externally-timed Window (ext_timed or win:ext_timed)</a></span></dt><dt><span class="sect2"><a href="epl-views.html#view-win-time-batch">13.3.5. Time batch Window (time_batch or win:time_batch)</a></span></dt><dt><span class="sect2"><a href="epl-views.html#view-win-ext-time-batch">13.3.6. Externally-timed Batch Window (ext_timed_batch or win:ext_timed_batch)</a></span></dt><dt><span class="sect2"><a href="epl-views.html#view-win-time-length-batch">13.3.7. Time-Length Combination Batch Window (time_length_batch or win:time_length_batch)</a></span></dt><dt><span class="sect2"><a href="epl-views.html#view-win-time-accumulating">13.3.8. Time-Accumulating Window (time_accum or win:time_accum)</a></span></dt><dt><span class="sect2"><a href="epl-views.html#view-win-keepall">13.3.9. Keep-All Window (keepall or win:keepall)</a></span></dt><dt><span class="sect2"><a href="epl-views.html#view-win-firstlength">13.3.10. First Length Window(firstlength or win:firstlength)</a></span></dt><dt><span class="sect2"><a href="epl-views.html#view-win-firsttime">13.3.11. First Time Window (firsttime or win:firsttime)</a></span></dt><dt><span class="sect2"><a href="epl-views.html#view-win-expr">13.3.12. Expiry Expression Window (expr or win:expr)</a></span></dt><dt><span class="sect2"><a href="epl-views.html#view-win-exprbatch">13.3.13. Expiry Expression Batch Window (expr_batch or win:expr_batch)</a></span></dt><dt><span class="sect2"><a href="epl-views.html#view-std-unique">13.3.14. Unique Window (unique or std:unique)</a></span></dt><dt><span class="sect2"><a href="epl-views.html#view-std-groupwin">13.3.15. Grouped Data Window (groupwin or std:groupwin)</a></span></dt><dt><span class="sect2"><a href="epl-views.html#view-std-last">13.3.16. Last Event Window (std:lastevent)</a></span></dt><dt><span class="sect2"><a href="epl-views.html#view-std-first">13.3.17. First Event Window (firstevent or std:firstevent)</a></span></dt><dt><span class="sect2"><a href="epl-views.html#view-std-firstunique">13.3.18. First Unique Window (firstunique or std:firstunique)</a></span></dt><dt><span class="sect2"><a href="epl-views.html#view-ext-sort">13.3.19. Sorted Window (sort or ext:sort)</a></span></dt><dt><span class="sect2"><a href="epl-views.html#view-ext-rank">13.3.20. Ranked Window (rank or ext:rank)</a></span></dt><dt><span class="sect2"><a href="epl-views.html#view-time-order">13.3.21. Time-Order Window (time_order or ext:time_order)</a></span></dt><dt><span class="sect2"><a href="epl-views.html#view-timetolive">13.3.22. Time-To-Live Window (timetolive or ext:timetolive)</a></span></dt></dl></dd><dt><span class="sect1"><a href="epl-views.html#stat-views">13.4. Special Derived-Value Windows</a></span></dt><dd><dl><dt><span class="sect2"><a href="epl-views.html#view-std-size">13.4.1. Size Derived-Value Window (size) or std:size)</a></span></dt><dt><span class="sect2"><a href="epl-views.html#view-stat-uni">13.4.2. Univariate Statistics Derived-Value Window (uni or stat:uni)</a></span></dt><dt><span class="sect2"><a href="epl-views.html#view-stat-linest">13.4.3. Regression Derived-Value Window (linest or stat:linest)</a></span></dt><dt><span class="sect2"><a href="epl-views.html#view-stat-correl">13.4.4. Correlation Derived-Value Window (correl or stat:correl)</a></span></dt><dt><span class="sect2"><a href="epl-views.html#view-stat-weightedavg">13.4.5. Weighted Average Derived-Value Window (weighted_avg or stat:weighted_avg)</a></span></dt></dl></dd></dl></div><a id="d0e33430" class="indexterm"/><p>
            This chapter outlines the data windows that are built into Esper.
			The section on <a class="xref" href="processingmodel.html" title="Chapter 2. Basic Concepts">Chapter 2, <i>Basic Concepts</i></a> provides additional information on the relationship of filtering, windows and aggregation. Please also see <a class="xref" href="epl_clauses.html#epl-from-clause-window-spec" title="5.4.3. Specifying Data Windows">Section 5.4.3, “Specifying Data Windows”</a> for the use of windows in the <code class="literal">from</code> clause with streams, patterns and named windows.
        </p><p>
            Data windows retain incoming events until an expiry policy indicates to release events. Thus data windows are a means of indicating what subset of events to analyze.
        </p><p>
            Two or more data windows can be combined. This allows a sets of events retained by one data window to be placed into a union or an intersection with the set of events retained by one or more other data windows. Please see <a class="xref" href="epl_clauses.html#epl-from-clause-view-multidatawindow" title="5.4.4. Multiple Data Windows">Section 5.4.4, “Multiple Data Windows”</a> for more detail.
        </p><p>
			The keep-all data window counts as a data window but has no expiry policy: it retains all events received. The grouped-window declaration allocates a new data window per grouping criteria and thereby counts as a data window, but cannot appear alone.
        </p><p>
            The next table summarizes data windows:
        </p><div class="table"><a id="d0e33454"/><p class="title"><b>Table 13.1. Built-in Data Windows</b></p><div class="table-contents"><table summary="Built-in Data Windows" border="1"><colgroup><col/><col/><col/></colgroup><thead><tr><th>Data Window</th><th>Syntax</th><th>Description</th></tr></thead><tbody><tr><td>Length Window</td><td><code class="literal">length(</code><span class="emphasis"><em>size</em></span><code class="literal">)</code></td><td>Sliding length window extending the specified number of elements into the past.</td></tr><tr><td>Length Batch Window</td><td><code class="literal">length_batch(</code><span class="emphasis"><em>size</em></span><code class="literal">)</code></td><td>Tumbling window that batches events and releases them when a given minimum number of events has been collected.</td></tr><tr><td>Time Window</td><td><code class="literal">time(</code><span class="emphasis"><em>time period</em></span><code class="literal">)</code></td><td>Sliding time window extending the specified time interval into the past.</td></tr><tr><td>Externally-timed Window</td><td><code class="literal">ext_timed(</code><span class="emphasis"><em>timestamp expression</em></span>, <span class="emphasis"><em>time period</em></span><code class="literal">)</code></td><td>Sliding time window, based on the long-type time value supplied by an expression.</td></tr><tr><td>Time Batch Window</td><td><code class="literal">time_batch(</code><span class="emphasis"><em>time period</em></span>[,<span class="emphasis"><em>optional reference point</em></span>] [, <span class="emphasis"><em>flow control</em></span>]<code class="literal">)</code></td><td>Tumbling window that batches events and releases them every specified time interval, with flow control options.</td></tr><tr><td>Externally-timed Batch Window</td><td><code class="literal">ext_timed_batch(</code><span class="emphasis"><em>timestamp expression</em></span>, <span class="emphasis"><em>time period</em></span>[,<span class="emphasis"><em>optional reference point</em></span>]<code class="literal">)</code></td><td>Tumbling window that batches events and releases them every specified time interval based on the long-type value supplied by an expression.</td></tr><tr><td>Time-Length Combination Batch Window</td><td><code class="literal">time_length_batch(</code><span class="emphasis"><em>time period, size [, flow control]</em></span><code class="literal">)</code></td><td>Tumbling multi-policy time and length batch window with flow control options.</td></tr><tr><td>Time-Accumulating Window</td><td><code class="literal">time_accum(</code><span class="emphasis"><em>time period</em></span><code class="literal">)</code></td><td>Sliding time window accumulates events until no more events arrive within a given time interval.</td></tr><tr><td>Keep-All Window</td><td><code class="literal">keepall</code></td><td>The keep-all data window simply retains all events.</td></tr><tr><td>Sorted Window</td><td><code class="literal">sort(</code><span class="emphasis"><em>size, sort criteria</em></span><code class="literal">)</code></td><td>Sorts by values returned by sort criteria expressions and keeps only the top events up to the given size.</td></tr><tr><td>Ranked Window</td><td><code class="literal">rank(</code><span class="emphasis"><em>unique criteria(s), size, sort criteria(s)</em></span><code class="literal">)</code></td><td>Retains only the most recent among events having the same value for the criteria expression(s) sorted by sort criteria expressions and keeps only the top events up to the given size.</td></tr><tr><td>Time-Order Window</td><td><code class="literal">time_order(</code><span class="emphasis"><em>timestamp expression, time period</em></span><code class="literal">)</code></td><td>Orders events that arrive out-of-order, using an expression providing timestamps to be ordered.</td></tr><tr><td>Time-To-Live Window</td><td><code class="literal">timetolive(</code><span class="emphasis"><em>timestamp expression</em></span><code class="literal">)</code></td><td>Retains events until the time returned by the timestamp expression.</td></tr><tr><td>Unique Window</td><td><code class="literal">unique(</code><span class="emphasis"><em>unique criteria(s)</em></span><code class="literal">)</code></td><td>Retains only the most recent among events having the same value for the criteria expression(s). Acts as a length window of size 1 for each distinct expression value.</td></tr><tr><td>Grouped Data Window</td><td><code class="literal">groupwin(</code><span class="emphasis"><em>grouping criteria(s)</em></span><code class="literal">)</code></td><td>Groups events into sub-data-windows by the value of the specified expression(s), generally used to provide a separate data window per group.</td></tr><tr><td>Last Event Window</td><td><code class="literal">lastevent</code></td><td>Retains the last event, acts as a length window of size 1.</td></tr><tr><td>First Event Window</td><td><code class="literal">firstevent</code></td><td>Retains the very first arriving event, disregarding all subsequent events.</td></tr><tr><td>First Unique Window</td><td><code class="literal">firstunique(</code><span class="emphasis"><em>unique criteria(s)</em></span><code class="literal">)</code></td><td>Retains only the very first among events having the same value for the criteria expression(s), disregarding all subsequent events for same value(s).</td></tr><tr><td>First Length Window</td><td><code class="literal">firstlength(</code><span class="emphasis"><em>size</em></span><code class="literal">)</code></td><td>Retains the first <span class="emphasis"><em>size</em></span> events, disregarding all subsequent events.</td></tr><tr><td>First Time Window</td><td><code class="literal">firsttime(</code><span class="emphasis"><em>time period</em></span><code class="literal">)</code></td><td>Retains the events arriving until the time interval has passed, disregarding all subsequent events.</td></tr><tr><td>Expiry Expression Window</td><td><code class="literal">expr(</code><span class="emphasis"><em>expiry expression</em></span><code class="literal">)</code></td><td>Expire events based on the result of an expiry expression passed as a parameter.</td></tr><tr><td>Expiry Expression Batch Window</td><td><code class="literal">expr_batch(</code><span class="emphasis"><em>expiry expression</em></span><code class="literal">)</code></td><td>Tumbling window that batches events and releases them based on the result of an expiry expression passed as a parameter.</td></tr></tbody></table></div></div><br class="table-break"/><a id="d0e33742" class="indexterm"/><p>
			There is a special kind of data window that is used less frequently, and is called a derived-value window. They are windows that derive a new value from event streams and post the result as events of a new type.
			The table below summarizes these special derived-value windows.
        </p><div class="table"><a id="d0e33749"/><p class="title"><b>Table 13.2. Built-in Derived-Value Data Windows</b></p><div class="table-contents"><table summary="Built-in Derived-Value Data Windows" border="1"><colgroup><col/><col/><col/></colgroup><thead><tr><th>Data Window</th><th>Syntax</th><th>Description</th></tr></thead><tbody><tr><td>Size</td><td><code class="literal">size(</code>[<span class="emphasis"><em>expression</em></span>, ...]<code class="literal">)</code></td><td>Derives a count of the number of events in a data window, or in an insert stream if used without a data window, and optionally provides additional event properties as listed in parameters.</td></tr><tr><td>Univariate statistics</td><td><code class="literal">uni(</code><span class="emphasis"><em>value expression</em></span> [,<span class="emphasis"><em>expression</em></span>, ...]<code class="literal">)</code></td><td>Calculates univariate statistics on the values returned by the expression.</td></tr><tr><td>Regression</td><td><code class="literal">linest(</code><span class="emphasis"><em>value expression, value expression</em></span> [,<span class="emphasis"><em>expression</em></span>, ...]<code class="literal">)</code></td><td>Calculates regression on the values returned by two expressions.</td></tr><tr><td>Correlation</td><td><code class="literal">correl(</code><span class="emphasis"><em>value expression, value expression</em></span> [,<span class="emphasis"><em>expression</em></span>, ...]<code class="literal">)</code></td><td>Calculates the correlation value on the values returned by two expressions.</td></tr><tr><td>Weighted average</td><td><code class="literal">weighted_avg(</code><span class="emphasis"><em>value expression, value expression</em></span> [,<span class="emphasis"><em>expression</em></span>, ...]<code class="literal">)</code></td><td>Calculates weighted average given a weight expression and an expression to compute the average for.</td></tr></tbody></table></div></div><br class="table-break"/><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="view-parameters"/>13.1. A Note on Data Window Name and Parameters</h2></div></div></div><p>
			   The syntax for data windows starts with data window name and is followed by optional parameter expressions in parenthesis:
		   </p><pre class="synopsis"><span class="emphasis"><em>name</em></span>(<span class="emphasis"><em>window_parameters</em></span>)</pre><p>
			   This example specifies a time window of 5 seconds:
		   </p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select * from StockTickEvent#time(5 sec)</pre><p>
			  Esper organizes built-in data windows in namespaces and names. Windows that provide sliding or tumbling data windows are in the <code class="literal">win</code> namespace. Other most commonly used windows are in the <code class="literal">std</code> namespace. The <code class="literal">ext</code> namespace are window that order events. The <code class="literal">stat</code> namespace is used for windows that derive statistical data.
			</p><p>
			   Alternatively you may specify the namespace name and <code class="literal">:</code> colon character.			
		   </p><pre class="synopsis"><span class="emphasis"><em>namespace</em></span>:<span class="emphasis"><em>name</em></span>(<span class="emphasis"><em>window_parameters</em></span>)</pre><p>
			   The below examples all specify a time window of 5 seconds:
		   </p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select * from StockTickEvent#time(5 sec)</pre><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select * from StockTickEvent#win:time(5 sec)</pre><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select * from StockTickEvent.win:time(5 sec)</pre><p>
			   All expressions are allowed as parameters to data windows, including expressions that contain variables or substitution parameters for prepared statements. Subqueries, the special <code class="literal">prior</code> and <code class="literal">prev</code> functions and aggregations (with the exception of the expression window and expression batch window) are not allowed as data window parameters.
		   </p><p>
			   For example, assuming a variable by name <code class="literal">VAR_WINDOW_SIZE</code> is defined:
		   </p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select * from StockTickEvent#time(VAR_WINDOW_SIZE)</pre><p>
			   The system evaluates expression parameters for data windows at the time of context partition instantiation with the exception of the expression window (<code class="literal">expr</code>) and expression batch window (<code class="literal">expr_batch</code>). 
		   </p><p>
			   Also consider multiple data windows in intersection or union (keywords <code class="literal">retain-intersection</code> and <code class="literal">retain-union</code>). Consider writing a custom plug-in data window if your application requires behavior that is not yet provided by any of the built-in windows.
		   </p><p>
			   If a window takes no parameters you may leave parenthesis off or the use empty parenthesis <code class="literal">()</code>.
		   </p><p>
			   The below examples all specify a keep-all window:
		   </p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select * from StockTickEvent#keepall</pre><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select * from StockTickEvent#keepall()</pre><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select * from StockTickEvent.win:keepall()</pre><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select * from StockTickEvent.win:keepall</pre><p>
			   Expression parameters can reference context-provided properties. For example:
		   </p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">create schema ParameterEvent(windowSize int)</pre><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">create context MyContext initiated by ParameterEvent as params terminated after 1 year</pre><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">context MyContext select * from StockTickEvent#length(context.params.windowSize)</pre></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="view-batchwindows"/>13.2. A Note on Batch Windows</h2></div></div></div><p>
			   Batch windows buffer events until a certain threshold is reached and then release the batched events for processing. 
			   The released events become the insert stream events and the previous batch of events constitutes the remove stream events.
			   Batch windows thus retain the current and the last batch of events in memory.
		   </p><p>
			   It is often desirable to aggregate without retaining events in memory, or with just keeping the current events in memory (and not also the last batch of events). 
			   You can declare a context and define what starts and ends a "batch" instead.
			   Contexts provide a large degree of freedom in allowing batches to overlap, in allowing batches to span multiple statements and in allowing batches to have complex start and end conditions.
			   They are further described in <a class="xref" href="context.html" title="Chapter 4. Context and Context Partitions">Chapter 4, <i>Context and Context Partitions</i></a>.
		   </p><p>
			   This example declares a non-overlapping context that spans a time interval of 3 seconds (i.e. a batch of 3 seconds):
		   </p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">create context IntervalSpanning3Seconds start @now end after 3 sec</pre><p>
			   The next example EPL aggregates events without retaining events in memory and outputs at the end of each interval:
		   </p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">context IntervalSpanning3Seconds select count(*) from Events output snapshot when terminated</pre><p>
			   Here is an example that outputs all events when at least 10 events, in the 3-second interval, have collected:
		   </p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">context IntervalSpanning3Seconds select window(*) from Events#keepall having count(*) &gt;= 10</pre><p>
				For the examples above, at the end of each 3-second interval, the engine discards all data windows and aggregation state.
				If your application would like 3-second intervals keyed by some fields please consider a nested context declaration with a keyed segmented context, for example:
			</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">create context PerSymbolInterval3Sec 
  context ById partition by symbol from StockTick, 
  context Interval3Sec start @now end after 3 sec</pre><p>
				Batch windows keep not only the current batch in memory but also the previous batch of events. 
				For example, let's say at time 0 an event arrives and enters the batch window. 
				At time 3 seconds (3-second batch window) the event becomes an insert-stream event and the engine now updates aggregations for that batch (i.e. count goes up to 1). 
				At time 6 seconds the event becomes a remove-stream event and the engine now updates aggregations for that batch (i.e. count goes down to 0).
				Since the engine continually updates aggregations from insert and remove stream events, and does not re-compute aggregations, batch windows follow the same paradigm. 
			</p></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="win-views"/>13.3. Data Windows</h2></div></div></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="view-win-length"/>13.3.1. Length Window (<code class="literal">length</code> or <code class="literal">win:length</code>)</h3></div></div></div><a id="d0e33989" class="indexterm"/><a id="d0e33992" class="indexterm"/><p>
					This window is a moving (sliding) length window extending the specified number of elements into the past. The window takes a single expression as a parameter providing a numeric size value that defines the window size:
				</p><pre class="synopsis">length(<span class="emphasis"><em>size_expression</em></span>)</pre><p>
					The below example sums the price for the last 5 stock ticks for symbol GE.
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select sum(price) from StockTickEvent(symbol='GE')#length(5)</pre><p>
					The next example keeps a length window of 10 events of stock trade events, with a separate window for each symbol. The
					sum of price is calculated only for the last 10 events for each symbol and aggregates per symbol:
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select sum(price) from StockTickEvent#groupwin(symbol)#length(10) group by symbol</pre><p>
					A length window of 1 is equivalent to the last event window <code class="literal">lastevent</code>. The <code class="literal">lastevent</code> data window is the preferred notation:
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select * from StockTickEvent#lastevent	// Prefer this
// ... equivalent to ...
select * from StockTickEvent#length(1)</pre></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="view-win-length-batch"/>13.3.2. Length Batch Window (<code class="literal">length_batch</code> or <code class="literal">win:length_batch</code>)</h3></div></div></div><a id="d0e34031" class="indexterm"/><a id="d0e34034" class="indexterm"/><p>
					This window buffers events (tumbling window) and releases them when a given minimum number of events has been collected. Provide an expression defining the number of events to batch as a parameter:
				</p><pre class="synopsis">length_batch(<span class="emphasis"><em>size_expression</em></span>)</pre><p>
					The next statement buffers events until a minimum of 10 events have collected. Listeners to updates posted by this window receive updated information only when 10 or more events have collected.
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select * from StockTickEvent#length_batch(10)</pre></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="view-win-time"/>13.3.3. Time Window (<code class="literal">time</code> or <code class="literal">win:time</code>)</h3></div></div></div><a id="d0e34059" class="indexterm"/><a id="d0e34062" class="indexterm"/><p>
					This window is a moving (sliding) time window extending the specified time interval into the past based on the system time.
					Provide a time period (see <a class="xref" href="epl_clauses.html#epl-syntax-time-periods" title="5.2.1. Specifying Time Periods">Section 5.2.1, “Specifying Time Periods”</a>) or an expression defining the number of seconds as a parameter:
				</p><pre class="synopsis">time(<span class="emphasis"><em>time period</em></span>)</pre><pre class="synopsis">time(<span class="emphasis"><em>seconds_interval_expression</em></span>)</pre><p>
					For the GE stock tick events in the last 1 second, calculate a sum of price.
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select sum(price) from StockTickEvent(symbol='GE')#time(1 sec)</pre><p>
					The following time windows are equivalent specifications:
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">time(2 minutes 5 seconds)
time(125 sec)
time(125)
time(MYINTERVAL)  // MYINTERVAL defined as a variable</pre></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="view-win-ext_time"/>13.3.4. Externally-timed Window (<code class="literal">ext_timed</code> or <code class="literal">win:ext_timed</code>)</h3></div></div></div><a id="d0e34098" class="indexterm"/><a id="d0e34101" class="indexterm"/><p>
					Similar to the time window, this window is a moving (sliding) time window extending the specified time interval into the past, but based on the long-type
					time value supplied by a timestamp expression. The window takes two parameters: the expression to return long-typed timestamp values,
					and a time period or expression that provides a number of seconds:
				</p><pre class="synopsis">ext_timed(<span class="emphasis"><em>timestamp_expression</em></span>, <span class="emphasis"><em>time_period</em></span>)</pre><pre class="synopsis">ext_timed(<span class="emphasis"><em>timestamp_expression</em></span>, <span class="emphasis"><em>seconds_interval_expression</em></span>)</pre><p>
					The key difference comparing the externally-timed window to the regular time window is that the window slides not based on the engine time, 
					but strictly based on the result of the timestamp expression when evaluated against the events entering the window.
				</p><p>
					The algorithm underlying the window compares the timestamp value returned by the expression when the oldest event arrived with the timestamp value returned by the expression for the newest arriving event on event arrival. 
					If the time interval between the timestamp values is larger then the timer period parameter, 
					then the algorithm removes all oldest events tail-first until the difference between the oldest and newest event is within the time interval. The window
					therefore slides only when events arrive and only considers each event's timestamp property (or other expression value returned) and not engine time.
				</p><p>
					This window holds stock tick events of the last 10 seconds based on the timestamp property in <code class="literal">StockTickEvent</code>.
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select * from StockTickEvent#ext_timed(timestamp, 10 seconds)</pre><p>
					The externally-timed data window expects strict ordering of the timestamp values returned by the timestamp expression. The window is not useful for ordering events in time order, please use the time-order window instead.
				</p><p>
				  On a related subject, engine time itself can be entirely under control of the application as described in <a class="xref" href="api.html#api-controlling-time" title="14.8. Controlling Time-Keeping">Section 14.8, “Controlling Time-Keeping”</a>, allowing control over all time-based aspects of processing
				  in one place.
				</p></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="view-win-time-batch"/>13.3.5. Time batch Window (<code class="literal">time_batch</code> or <code class="literal">win:time_batch</code>)</h3></div></div></div><a id="d0e34150" class="indexterm"/><a id="d0e34153" class="indexterm"/><p>
					This window buffers events (tumbling window) and releases them every specified time interval in one update. The window takes a time period or an expression providing a number of seconds as a parameter, plus optional parameters described next.
				</p><pre class="synopsis">time_batch(<span class="emphasis"><em>time_period</em></span> [,<span class="emphasis"><em>optional_reference_point</em></span>] [,<span class="emphasis"><em>flow_control</em></span>])</pre><pre class="synopsis">time_batch(<span class="emphasis"><em>seconds_interval_expression</em></span> [,<span class="emphasis"><em>optional_reference_point</em></span>] [,<span class="emphasis"><em>flow_control</em></span>])</pre><p>
					The time batch window takes a second, optional parameter that serves as a reference point to batch flush times. If not specified, the arrival of the first event into the batch window sets the 
					reference point. Therefore if the reference point is not specified and the first event arrives at time t<sub>1</sub>, then the batch flushes at time t<sub>1</sub> plus <span class="emphasis"><em>time_period</em></span> and every <span class="emphasis"><em>time_period</em></span> thereafter.
				</p><div xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>
						Please see <a class="xref" href="epl-views.html#view-batchwindows" title="13.2. A Note on Batch Windows">Section 13.2, “A Note on Batch Windows”</a> for information on what a batch window is and how to best to compute over intervals. 
					</p><p>
						Note that using this window means that the engine keeps events in memory until the time is up: Consider your event arrival rate and determine if this is the behavior you want. Use context declaration or output rate limiting such as <code class="literal">output snapshot</code> as an alternative.
					</p></div><p>
					The below example batches events into a 5 second window releasing new batches every 5 seconds. Listeners to updates
					posted by this window receive updated information only every 5 seconds.
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select * from StockTickEvent#time_batch(5 sec)</pre><p>
					By default, if there are no events arriving in the current interval (insert stream), and no events remain from the prior batch (remove stream), then the window does not post results to listeners. The window allows overriding this
					default behavior via flow control keywords.
				</p><p>
					The synopsis with flow control parameters is:
				</p><pre class="synopsis">time_batch(<span class="emphasis"><em>time_period or seconds_interval_expr</em></span> [,<span class="emphasis"><em>optional_reference_point</em></span>] 
    [, "flow-control-keyword [, keyword...]"] )</pre><p>
					The FORCE_UPDATE flow control keyword instructs the window to post an empty result set to listeners if there is no
					data to post for an interval. When using this keyword the <code class="literal">irstream</code> keyword should be used in the <code class="literal">select</code> clause to ensure the remove stream is also output. 
					Note that FORCE_UPDATE is for use with listeners to the same statement and not for use with named windows. Consider output rate limiting instead.
				</p><p>
					The START_EAGER flow control keyword instructs the window to post empty result sets even before the first event
					arrives, starting a time interval at statement creation time. As when using FORCE_UPDATE, the window also posts an
					empty result set to listeners if there is no data to post for an interval, however it starts doing so at time of statement
					creation rather then at the time of arrival of the first event.
				</p><p>
					Taking the two flow control keywords in one sample statement, this example presents a window that waits for 10
					seconds. It posts empty result sets after one interval after the statement is created, and keeps posting an empty result set as no events arrive during intervals:					
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select * from MyEvent#time_batch(10 sec, "FORCE_UPDATE, START_EAGER")</pre><p>
				  The optional reference point is provided as a long-value of milliseconds (or microseconds for microsecond engine time unit) relative to January 1, 1970 and time 00:00:00.
				</p><p>
				  The following example statement sets the reference point to 5 seconds and the batch size to 1 hour, so that each batch output is 5 seconds after each hour:
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select * from OrderSummaryEvent#time_batch(1 hour, 5000L)</pre></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="view-win-ext-time-batch"/>13.3.6. Externally-timed Batch Window (<code class="literal">ext_timed_batch</code> or <code class="literal">win:ext_timed_batch</code>)</h3></div></div></div><a id="d0e34251" class="indexterm"/><a id="d0e34254" class="indexterm"/><p>
				    Similar to the time batch window, this window buffers events (tumbling) and releases them every specified time interval in one update, 
				    but based on the long-type time value supplied by a timestamp expression.
					The window has two required parameters taking an expression that returns long-typed timestamp values and a time period or constant-value expression that provides a number of seconds:
				</p><pre class="synopsis">ext_timed_batch(<span class="emphasis"><em>timestamp_expression</em></span>, <span class="emphasis"><em>time_period</em></span> [,<span class="emphasis"><em>optional_reference_point</em></span>])</pre><pre class="synopsis">ext_timed_batch(<span class="emphasis"><em>timestamp_expression</em></span>, <span class="emphasis"><em>seconds_interval_expression</em></span> [,<span class="emphasis"><em>optional_reference_point</em></span>])</pre><p>
					The externally-timed batch window takes a third, optional parameter that serves as a reference point to batch flush times. If not specified, the arrival of the first event into the batch window sets the 
					reference point. Therefore if the reference point is not specified and the first event arrives at time t<sub>1</sub>, then the batch flushes at time t<sub>1</sub> plus <span class="emphasis"><em>time_period</em></span> and every <span class="emphasis"><em>time_period</em></span> thereafter.
				</p><p>
				   The key difference comparing the externally-timed batch window to the regular time batch window is that the window tumbles not based on the engine time, 
				   but strictly based on the result of the timestamp expression when evaluated against the events entering the window.
				</p><p>
					The algorithm underlying the window compares the timestamp value returned by the expression when the oldest event arrived with the timestamp value returned by the expression for the 
					newest arriving event on event arrival. If the time interval between the timestamp values is larger then the timer period parameter, then the algorithm posts the current batch of events. 
					The window therefore posts batches only when events arrive and only considers each event's timestamp property (or other expression value returned) and not engine time.
				</p><p>
					Note that using this window means that the engine keeps events in memory until the time is up: Consider your event arrival rate and determine if this is the behavior you want. Use context declaration or output rate limiting such as <code class="literal">output snapshot</code> as an alternative.
				</p><p>
					The below example batches events into a 5 second window releasing new batches every 5 seconds. Listeners to updates
					posted by this window receive updated information only when event arrive with timestamps that indicate the start of a new batch:
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select * from StockTickEvent#ext_timed_batch(timestamp, 5 sec)</pre><p>
				  The optional reference point is provided as a long-value of milliseconds (or microseconds) relative to January 1, 1970 and time 00:00:00.
				</p><p>
				  The following example statement sets the reference point to 5 seconds and the batch size to 1 hour, so that each batch output is 5 seconds after each hour:
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select * from OrderSummaryEvent#ext_timed_batch(timestamp, 1 hour, 5000L)</pre><p>
				  The externally-timed data window expects strict ordering of the timestamp values returned by the timestamp expression. 
				  The window is not useful for ordering events in time order, please use the time-order window instead.
				</p><p>
				  On a related subject, engine time itself can be entirely under control of the application as described in <a class="xref" href="api.html#api-controlling-time" title="14.8. Controlling Time-Keeping">Section 14.8, “Controlling Time-Keeping”</a>, allowing control over all time-based aspects of processing
				  in one place.
				</p></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="view-win-time-length-batch"/>13.3.7. Time-Length Combination Batch Window (<code class="literal">time_length_batch</code> or <code class="literal">win:time_length_batch</code>)</h3></div></div></div><a id="d0e34331" class="indexterm"/><a id="d0e34334" class="indexterm"/><p>
					This data window is a combination of time and length batch (tumbling) windows. Similar to the time and length batch windows, this batches events and releases the batched events when either one of the 
following conditions occurs, whichever occurs first: the data window has collected a given number of events, or a given time interval has passed.
				</p><p>
					The parameters take 2 forms. The first form accepts a time period or an expression providing a number of seconds, and an expression for the number of events:
				</p><pre class="synopsis">time_length_batch(<span class="emphasis"><em>time_period</em></span>, <span class="emphasis"><em>number_of_events_expression</em></span>)</pre><pre class="synopsis">time_length_batch(<span class="emphasis"><em>seconds_interval_expression</em></span>, <span class="emphasis"><em>number_of_events_expression</em></span>)</pre><p>
					The next example shows a time-length combination batch window that batches up to 100 events or all events arriving within a 1-second time interval, whichever condition occurs first:
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class=""> select * from MyEvent#time_length_batch(1 sec, 100)</pre><p>
					In this example, if 100 events arrive into the window before a 1-second time interval passes, the window posts the batch of 100 events. If less then 100 events arrive within a 1-second interval,
					the window posts all events that arrived within the 1-second interval at the end of the interval.
				</p><p>
					By default, if there are no events arriving in the current interval (insert stream), and no events remain from the prior batch (remove stream), then the window does not post results to listeners. This
					window allows overriding this default behavior via flow control keywords.
				</p><p>
					The synopsis of the window with flow control parameters is:
				</p><pre class="synopsis">time_length_batch(<span class="emphasis"><em>time_period or seconds_interval_expression</em></span>, <span class="emphasis"><em>number_of_events_expression</em></span>, 
    "<span class="emphasis"><em>flow control keyword [, keyword...]</em></span>")</pre><p>
					The <code class="literal">FORCE_UPDATE</code> flow control keyword instructs the window to post an empty result set to listeners if there is no data to post for an interval. The window begins posting no later then after one time interval passed after the first event arrives. When using this keyword the <code class="literal">irstream</code> keyword should be used in the <code class="literal">select</code> clause to ensure the remove stream is also output. 
				</p><p>
					The <code class="literal">START_EAGER</code> flow control keyword instructs the window to post empty result sets even before the first event arrives, starting a time interval at statement creation time. As when using <code class="literal">FORCE_UPDATE</code>, the window also posts an empty result set to listeners if there is no data to post for an interval, however it starts doing so at time of statement creation rather then at the time of arrival of the first event.
				</p><p>
					Taking the two flow control keywords in one sample statement, this example presents a window that waits for 10 seconds or reacts when the 5th event arrives, whichever comes first. It posts empty result sets after one interval after the statement is created, and keeps posting an empty result set as no events arrive during intervals: 
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class=""> select * from MyEvent#time_length_batch(10 sec, 5, "FORCE_UPDATE, START_EAGER")</pre></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="view-win-time-accumulating"/>13.3.8. Time-Accumulating Window (<code class="literal">time_accum</code> or <code class="literal">win:time_accum</code>)</h3></div></div></div><a id="d0e34412" class="indexterm"/><a id="d0e34415" class="indexterm"/><p>
					This data window is a specialized moving (sliding) time window that differs from the regular time window in that it accumulates events until no more events arrive within a given time interval, and only then releases the accumulated events as a remove stream.
				</p><p>
					The window accepts a single parameter: the time period or seconds-expression specifying the length of the time interval during which no events must arrive until the window releases accumulated events. The synopsis is as follows:
				</p><pre class="synopsis">time_accum(<span class="emphasis"><em>time_period</em></span>)</pre><pre class="synopsis">time_accum(<span class="emphasis"><em>seconds_interval_expression</em></span>)</pre><p>
					The next example shows a time-accumulating window that accumulates events, and then releases events if within the time interval no more events arrive:
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class=""> select * from MyEvent#time_accum(10 sec)</pre><p>
					This example accumulates events, until when for a period of 10 seconds no more MyEvent events arrive, at which time it posts all accumulated MyEvent events.
				</p><p>
					Your application may only be interested in the batches of events as events leave the data window. This can be done simply by selecting the remove stream of this data window, populated by the engine as accumulated events leave the data window all-at-once when no events arrive during the time interval following the time the last event arrived:
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class=""> select rstream * from MyEvent#time_accum(10 sec)</pre><p>
					If there are no events arriving, then the window does not post results to listeners. 
				</p></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="view-win-keepall"/>13.3.9. Keep-All Window (<code class="literal">keepall</code> or <code class="literal">win:keepall</code>)</h3></div></div></div><a id="d0e34455" class="indexterm"/><a id="d0e34458" class="indexterm"/><p>
					This keep-all data window simply retains all events. The window does not remove events from the data window, unless used with a named window and the <code class="literal">on delete</code> clause.
				</p><p>
					The window accepts no parameters. The synopsis is as follows:
				</p><pre class="synopsis">keepall</pre><p>
					The next example shows a keep-all window that accumulates all events received into the window:
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class=""> select * from MyEvent#keepall</pre><p>
					Note that since the window does not release events, care must be taken to prevent retained events from using all available resources.
				</p></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="view-win-firstlength"/>13.3.10. First Length Window(<code class="literal">firstlength</code> or <code class="literal">win:firstlength</code>)</h3></div></div></div><a id="d0e34487" class="indexterm"/><a id="d0e34490" class="indexterm"/><p>
					The <code class="literal">firstlength</code> window retains the very first <span class="emphasis"><em>size_expression</em></span> events.
				</p><p>
					The synopsis is:
				</p><pre class="synopsis">firstlength(<span class="emphasis"><em>size_expression</em></span>)</pre><p>
					If used within a named window and an <code class="literal">on-delete</code> clause deletes events, the window accepts further arriving events until the number of retained events reaches the size of <span class="emphasis"><em>size_expression</em></span>.
				</p><p>
					The below example creates a window that retains only the first 10 events:
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select * from MyEvent#firstlength(10)</pre></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="view-win-firsttime"/>13.3.11. First Time Window (<code class="literal">firsttime</code> or <code class="literal">win:firsttime</code>)</h3></div></div></div><a id="d0e34531" class="indexterm"/><a id="d0e34534" class="indexterm"/><p>
					The <code class="literal">firsttime</code> window retains all events arriving within a given time interval after statement start.
				</p><p>
					The synopsis is:
				</p><pre class="synopsis">firsttime(<span class="emphasis"><em>time_period</em></span>)</pre><pre class="synopsis">firsttime(<span class="emphasis"><em>seconds_interval_expression</em></span>)</pre><p>
					The below example creates a window that retains only those events arriving within 1 minute and 10 seconds of statement start:
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select * from MyEvent#firsttime(1 minute 10 seconds)</pre></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="view-win-expr"/>13.3.12. Expiry Expression Window (<code class="literal">expr</code> or <code class="literal">win:expr</code>)</h3></div></div></div><a id="d0e34569" class="indexterm"/><a id="d0e34572" class="indexterm"/><p>
					The <code class="literal">expr</code> data window applies an expiry expression and removes events from the data window when the expression returns false.
				</p><p>
				   Use this window to implement rolling and dynamically shrinking or expanding time, length or other windows. Rolling can, for example, be controlled based on event properties of arriving events, based on aggregation values or based on the return result of user-defined functions. Use this window to accumulate events until a value changes or other condition occurs based on arriving events or change of a variable value.
				 </p><p>
					The synopsis is:
				</p><pre class="synopsis">expr(<span class="emphasis"><em>expiry_expression</em></span>)</pre><p>
					The expiry expression can be any expression including expressions on event properties, variables, aggregation functions or user-defined functions. The window applies this expression to the oldest event(s) currently in the window, as described next.
				</p><p>
					When a new event arrives or when a variable value referenced by the expiry expression changes then the window applies the expiry expression starting from the oldest event in the data window.
					If the expiry expression returns false for the oldest event, the window removes the event from the data window. The window then applies the expression to the next oldest event.
					If the expiry expression returns true for the oldest event, no further evaluation takes place and the window indicates any new and expired events through insert and remove stream.
				</p><p>
					By using variables in the expiry expression it is possible to change the behavior of the window dynamically at runtime. When one or more variables used in the expression are updated the window evaluates the expiry expression starting from the oldest event.
				</p><p>
					Aggregation functions, if present in the expiry expression, are continuously updated as events enter and leave the data window. Use the grouped data window with this window to compute aggregations per group.
				</p><p>
					The engine makes the following built-in properties available to the expiry expression:
				</p><div class="table"><a id="d0e34601"/><p class="title"><b>Table 13.3. Built-in Properties of the Expiry Expression Data Window</b></p><div class="table-contents"><table summary="Built-in Properties of the Expiry Expression Data Window" border="1"><colgroup><col/><col/><col/></colgroup><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code class="literal">current_count</code></td><td>int</td><td>The number of events in the data window including the currently-arriving event.</td></tr><tr><td><code class="literal">expired_count</code></td><td>int</td><td>The number of events expired during this evaluation.</td></tr><tr><td><code class="literal">newest_event</code></td><td>(same event type as arriving events)</td><td>The last-arriving event itself.</td></tr><tr><td><code class="literal">newest_timestamp</code></td><td>long</td><td>The engine timestamp associated with the last-arriving event.</td></tr><tr><td><code class="literal">oldest_event</code></td><td>(same event type as arriving events)</td><td>The currently-evaluated event itself.</td></tr><tr><td><code class="literal">oldest_timestamp</code></td><td>long</td><td>The engine timestamp associated with the currently-evaluated event.</td></tr><tr><td><code class="literal">view_reference</code></td><td>Object</td><td>The object handle to this data window.</td></tr></tbody></table></div></div><br class="table-break"/><p>
					This EPL declares an expiry expression that retains the last 2 events:
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select * from MyEvent#expr(current_count &lt;= 2)</pre><p>
					The following example implements a dynamically-sized length window by means of a SIZE variable. As the SIZE variable value changes 
					the window retains the number of events according to the current value of SIZE:
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">create variable int SIZE = 1000</pre><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select * from MyEvent#expr(current_count &lt;= SIZE)</pre><p>
					The next EPL retains the last 2 seconds of events:
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select * from MyEvent#expr(oldest_timestamp &gt; newest_timestamp - 2000)</pre><p>
					The following example implements a dynamically-sized time window. As the SIZE long-type variable value changes 
					the window retains a time interval accordingly:
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">create variable long SIZE = 1000</pre><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select * from MyEvent#expr(newest_timestamp - oldest_timestamp &lt; SIZE)</pre><p>
					The following example declares a KEEP variable and flushes all events from the data window when the variable turns false:
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">create variable boolean KEEP = true</pre><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select * from MyEvent#expr(KEEP)</pre><p>
					The next example specifies a rolling window that removes the oldest events from the window until the total price of all events in the window is less then 1000:
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select * from MyEvent#expr(sum(price) &lt; 1000)</pre><p>
					This example retains all events that have the same value of the <code class="literal">flag</code> event property. When the <code class="literal">flag</code> value changes,
					the data window expires all events with the old <code class="literal">flag</code> value and retains only the most recent event of the new <code class="literal">flag</code> value:
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select * from MyEvent#expr(newest_event.flag = oldest_event.flag)</pre><div class="sect3" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="view-win-expr-limit"/>13.3.12.1. Limitations</h4></div></div></div><p>
						You may not use subqueries or the <code class="literal">prev</code> and <code class="literal">prior</code> functions as part of the expiry expression. Consider using a named window and <code class="literal">on-delete</code> or <code class="literal">on-merge</code> instead.
					</p><p>
					  When using variables in the expiry expression, the thread that updates the variable does not evaluate the window. The thread that updates the variable instead schedules a reevaluation and window evaluates by timer execution.
					</p></div></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="view-win-exprbatch"/>13.3.13. Expiry Expression Batch Window (<code class="literal">expr_batch</code> or <code class="literal">win:expr_batch</code>)</h3></div></div></div><a id="d0e34747" class="indexterm"/><a id="d0e34750" class="indexterm"/><p>					
					The <code class="literal">expr_batch</code> buffers events (tumbling window) and releases them when a given expiry expression returns true.
				</p><p>
				  Use this window to implement dynamic or custom batching behavior, such as for dynamically shrinking or growing time, length or other batches, for batching based on event properties of arriving events, aggregation values or for batching based on a user-defined function.
				</p><p>
					The synopsis is:
				</p><pre class="synopsis">expr_batch(<span class="emphasis"><em>expiry_expression</em></span>, [<span class="emphasis"><em>include_triggering_event</em></span>])</pre><p>
					The expiry expression can be any expression including expressions on event properties, variables, aggregation functions or user-defined functions. The window applies this expression to arriving event(s), as described next.
				</p><p>
					The optional second parameter <span class="emphasis"><em>include_triggering_event</em></span> defines whether to include the event that triggers the batch in the current batch (<code class="literal">true</code>, the default) or in the next batch (<code class="literal">false</code>).
				</p><p>
					When a new event arrives or when a variable value referenced by the expiry expression changes or when events get removed from the data window then the window applies the expiry expression. 
					If the expiry expression returns true the data window posts the collected events as the insert stream and the last batch of events as remove stream.
				</p><p>
					By using variables in the expiry expression it is possible to change the behavior of the window dynamically at runtime. When one or more variables used in the expression are updated the window evaluates the expiry expression as well.
				</p><p>
					Aggregation functions, if present in the expiry expression, are continuously updated as events enter the data window and reset when the engine posts a batch of events. Use the grouped data window with this window to compute aggregations per group.
				</p><p>
					The engine makes the following built-in properties available to the expiry expression:
				</p><div class="table"><a id="d0e34793"/><p class="title"><b>Table 13.4. Built-in Properties of the Expiry Expression Data Window</b></p><div class="table-contents"><table summary="Built-in Properties of the Expiry Expression Data Window" border="1"><colgroup><col/><col/><col/></colgroup><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code class="literal">current_count</code></td><td>int</td><td>The number of events in the data window including the currently-arriving event.</td></tr><tr><td><code class="literal">newest_event</code></td><td>(same event type as arriving events)</td><td>The last-arriving event itself.</td></tr><tr><td><code class="literal">newest_timestamp</code></td><td>long</td><td>The engine timestamp associated with the last-arriving event.</td></tr><tr><td><code class="literal">oldest_event</code></td><td>(same event type as arriving events)</td><td>The currently-evaluated event itself.</td></tr><tr><td><code class="literal">oldest_timestamp</code></td><td>long</td><td>The engine timestamp associated with the currently-evaluated event.</td></tr><tr><td><code class="literal">view_reference</code></td><td>Object</td><td>The object handle to this window.</td></tr></tbody></table></div></div><br class="table-break"/><p>
					This EPL declares an expiry expression that posts event batches consisting of 2 events:
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select * from MyEvent#expr_batch(current_count &gt;= 2)</pre><p>
					The following example implements a dynamically-sized length batch window by means of a SIZE variable. As the SIZE variable value changes 
					the window accumulates and posts the number of events according to the current value of SIZE:
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">create variable int SIZE = 1000</pre><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select * from MyEvent#expr_batch(current_count &gt;= SIZE)</pre><p>
					The following example accumulates events until an event arrives that has a value of <code class="literal">postme</code> for property <code class="literal">myvalue</code>:
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select * from MyEvent#expr_batch(myvalue = 'postme')</pre><p>
					The following example declares a POST variable and posts a batch of events when the variable turns true:
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">create variable boolean POST = false</pre><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select * from MyEvent#expr_batch(POST)</pre><p>
					The next example specifies a tumbling window that posts a batch of events when the total price of all events in the window is greater then 1000:
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select * from MyEvent#expr_batch(sum(price) &gt; 1000)</pre><p>
				  Specify the second parameter as <code class="literal">false</code> when you want the triggering event not included in the current batch.
				</p><p>
					This example batches all events that have the same value of the <code class="literal">flag</code> event property. When the <code class="literal">flag</code> value changes,
					the data window releases the batch of events collected for the old <code class="literal">flag</code> value. The data window collects the most recent event and the future arriving events of the same new <code class="literal">flag</code> value:
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select * from MyEvent#expr_batch(newest_event.flag != oldest_event.flag, false)</pre><div class="sect3" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="view-win-exprbatch-limit"/>13.3.13.1. Limitations</h4></div></div></div><p>
						You may not use subqueries or the <code class="literal">prev</code> and <code class="literal">prior</code> functions as part of the expiry expression. Consider using a named window and <code class="literal">on-delete</code> or <code class="literal">on-merge</code> instead.
					</p><p>
					  When using variables in the expiry expression, the thread that updates the variable does not evaluate the window. The thread that updates the variable instead schedules a reevaluation and window evaluates by timer execution.
					</p></div></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="view-std-unique"/>13.3.14. Unique Window (<code class="literal">unique</code> or <code class="literal">std:unique</code>)</h3></div></div></div><a id="d0e34936" class="indexterm"/><a id="d0e34939" class="indexterm"/><p>
					The <code class="literal">unique</code> window is a window that includes only the most recent among events having the same value(s) for the result of the specified expression or list of expressions.
				</p><p>
					The synopsis is:
				</p><pre class="synopsis">unique(<span class="emphasis"><em>unique_expression</em></span> [, <span class="emphasis"><em>unique_expression</em></span> ...])</pre><p>
					The window acts as a length window of size 1 for each distinct value returned by an expression, or combination of values returned by multiple expressions. It thus posts as old events the prior event of the same value(s), if any.
				</p><p>
					An expression may return a <code class="literal">null</code> value. The engine treats a <code class="literal">null</code> value as any other value. An expression can also return a custom application object, whereby the application class should implement the <code class="literal">hashCode</code> and <code class="literal">equals</code> methods.
				</p><p>
					The below example creates a window that retains only the last event per symbol.
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select * from StockTickEvent#unique(symbol)</pre><p>
					The next example creates a window that retains the last event per symbol and feed.
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select * from StockTickEvent#unique(symbol, feed)</pre><p>
					When using <code class="literal">unique</code> the engine plans queries applying an implicit unique index, where applicable. 
					Specify <code class="literal">@Hint('disable_unique_implicit_idx')</code> to force the engine to plan queries using a non-unique index.
				</p></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="view-std-groupwin"/>13.3.15. Grouped Data Window (<code class="literal">groupwin</code> or <code class="literal">std:groupwin</code>)</h3></div></div></div><a id="d0e35000" class="indexterm"/><a id="d0e35003" class="indexterm"/><p>
					Specifying <code class="literal">#groupwin</code> groups events into sub-data-window by the value returned by the specified expression or the combination of values returned by a list of expressions. The <code class="literal">#groupwin</code> takes a single expression to supply the group criteria values, or a list of expressions as parameters, as the synopsis shows:
				</p><pre class="synopsis">groupwin(<span class="emphasis"><em>grouping_expression</em></span> [, <span class="emphasis"><em>grouping_expression</em></span> ...])</pre><p>
					The <span class="emphasis"><em>grouping_expression</em></span> expression(s) return one or more group keys, by which it creates a separate data window for each distinct group key. Note that the expression should not return an unlimited number of values: the grouping expression should not
					return a time value or otherwise unlimited key. 
				</p><p>
					An expression may return a <code class="literal">null</code> value. The engine treats a <code class="literal">null</code> value as any other value. An expression can also return a custom application object, whereby the application class should implement the <code class="literal">hashCode</code> and <code class="literal">equals</code> methods.
				</p><p>
					You can specify a single <code class="literal">groupwin</code> per stream. Multiple <code class="literal">groupwin</code> declarations for the same stream are not allowed.
				</p><p>
					Use <code class="literal">group by</code> instead of the grouped data window to control how aggregations are grouped.
				</p><p>
					A grouped data window with a length window of 1 is equivalent to the unique data window <code class="literal">unique</code>. The <code class="literal">unique</code> data window is the preferred notation:
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select * from StockTickEvent#unique(symbol)	// Prefer this
// ... equivalent to ...
select * from StockTickEvent#groupwin(symbol)#length(1)</pre><p>
					This example computes the total price for the last 5 events considering the last 5 events per each symbol, aggregating the price across all symbols (since no <code class="literal">group by</code> clause is specified the aggregation is across all symbols):
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select symbol, sum(price) from StockTickEvent#groupwin(symbol)#length(5)</pre><p>
					The @Hint("<code class="literal">reclaim_group_aged=</code><span class="emphasis"><em>age_in_seconds</em></span>") hint instructs the engine to discard grouped data window state that has not been updated for <span class="emphasis"><em>age_in_seconds</em></span> seconds. 
					The optional @Hint("<code class="literal">reclaim_group_freq=</code><span class="emphasis"><em>sweep_frequency_in_seconds</em></span>") can be specified in addition to control the frequency at which the engine sweeps data window state.
					If the hint is not specified, the frequency defaults to the same value as <span class="emphasis"><em>age_in_seconds</em></span>. Use the hints when your group criteria returns a changing or unlimited number of values. By default and without hints the data window does not reclaim or remove data windows for group criteria values.
				</p><p>
					The updated sample statement with both hints:
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">// Remove data window for symbols not updated for 10 seconds or more and sweep every 30 seconds
@Hint('reclaim_group_aged=10,reclaim_group_freq=30')
select symbol, sum(price) from StockTickEvent#groupwin(symbol)#length(5)</pre><p>
					Reclaim executes when an event arrives and not in the timer thread. In the example above reclaim can occur up to 40 seconds of engine time after the newest event arrives.
					Reclaim may affect iteration order for the statement and iteration order becomes indeterministic with reclaim.
				</p><p>
					To compute the total price for the last 5 events considering the last 5 events per each symbol and outputting a price per symbol, add the <code class="literal">group by</code> clause:
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select symbol, sum(price) from StockTickEvent#groupwin(symbol)#length(5) group by symbol</pre><p>
					The <code class="literal">groupwin</code> grouped-window can also take multiple expressions that provide values to group by. This example computes the total price for each symbol and feed for the last 10 events per symbol and feed combination:
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select sum(price) from StockTickEvent#groupwin(symbol, feed)#length(10)</pre><p>
					The order in which the <code class="literal">groupwin</code> grouped-window appears controls the data the engine derives from events for each group. The next 2 statements demonstrate this using a length window.
				</p><p>
					Without the <code class="literal">groupwin</code> declaration query the same query returns the total price per symbol for only the last 10 events across all symbols. Here the engine allocates only one length window for all events:
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select sum(price) from StockTickEvent#length(10)</pre><p>
					We have learned that by placing the <code class="literal">groupwin</code> grouped-window before other data windows, these other data windows become part of the grouped set of windows. The engine dynamically allocates a new window instance for each, every time it encounters a new group key such as a new value for symbol. Therefore, in <code class="literal">groupwin(symbol)#length(10)</code> the engine allocates a new length window for each distinct symbol. However in <code class="literal">length(10)</code> alone the engine maintains a single length window.
				</p><p>
					The <code class="literal">groupwin</code> can be used with multiple data windows to achieve a grouped intersection or union policy.
				</p><p>
					The next query retains the last 4 events per symbol and only those events that are also not older then 10 seconds:
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select * from StockTickEvent#groupwin(symbol)#length(4)#time(10)</pre><p>
					Last, considers a grouped data window for two group criteria. Here, the query results are total price per symbol and feed for the last 100 events per symbol and feed.
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select sum(price) from StockTickEvent#groupwin(symbol, feed)#length(100)</pre><div xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>
					  A note on grouped time windows: When using grouped-window with time windows, note that whether the engine retains 5 minutes of events or retains 5 minutes of events per group, the result is the same from the perspective of retaining events as both policies retain, considering all groups, the same set of events. Therefore please specify the time window alone (ungrouped).
					</p><p>
						For example:
					</p><pre xmlns="" class="">// Use this:
select sum(price) from StockTickEvent#time(1 minute)

// is equivalent to (don't use this):
// select sum(price) from StockTickEvent#groupwin(symbol)#time(1 minute)

// Use the group-by clause for grouping aggregation by symbol.</pre></div><p>
					For advanced users: There is an optional declaration that can control how the <code class="literal">groupwin</code> grouped-window gets evaluated and that is <code class="literal">#merge</code>. 
					The merge can only occur after a <code class="literal">groupwin</code> grouped-window. It controls the end of the grouped declaration. 
				</p><p>
					Compare the following statements:
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select * from Market#groupwin(ticker)#length(1000000)
    #weighted_avg(price, volume)#merge(ticker)
// ... and ...
select * from Market#groupwin(ticker)#length(1000000)#merge(ticker)
    #weighted_avg(price, volume)</pre><p>
					If your statement does not specify the optional <code class="literal">#merge</code>, the semantics are the same as the first statement.
				</p><p>
					The first statement, in which the <code class="literal">#merge</code>is added to the end (same as no merge), computes weighted average per ticker, considering, per-ticker, the last 1M Market events for each ticker.
					The second statement, in which the merge is added to the middle, computes weighted average considering, per-ticker, the last 1M Market events, computing the weighted average for all such events using a single data window rather then multiple data window instances with one window per ticker. 
				</p></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="view-std-last"/>13.3.16. Last Event Window (<code class="literal">std:lastevent</code>)</h3></div></div></div><a id="d0e35185" class="indexterm"/><a id="d0e35188" class="indexterm"/><p>
					This window exposes the last element:
				</p><pre class="synopsis">lastevent</pre><p>
					The window acts as a length window of size 1. It thus posts as old events the prior event in the stream, if any.
				</p><p>
					This example statement retains the last stock tick event for the symbol GE. 
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select * from StockTickEvent(symbol='GE')#lastevent</pre><p>
					If you want to output the last event within a sliding window, please see <a class="xref" href="functionreference.html#epl-single-row-function-ref-previous" title="10.1.12. The Previous Function">Section 10.1.12, “The Previous Function”</a>. That function accepts a relative (count) or absolute index and returns event properties or an event in the context of the specified data window.
				</p></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="view-std-first"/>13.3.17. First Event Window (<code class="literal">firstevent</code> or <code class="literal">std:firstevent</code>)</h3></div></div></div><a id="d0e35216" class="indexterm"/><a id="d0e35219" class="indexterm"/><p>
					This window retains only the first arriving event:
				</p><pre class="synopsis">firstevent</pre><p>
					All events arriving after the first event are discarded.
				</p><p>
					If used within a named window and an <code class="literal">on-delete</code> clause deletes the first event, the window resets and will retain the next arriving event.
				</p><p>
					An example of a statement that retains the first <code class="literal">ReferenceData</code> event arriving is:
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select * from ReferenceData#firstevent</pre><p>
					If you want to output the first event within a sliding window, please see <a class="xref" href="functionreference.html#epl-single-row-function-ref-previous" title="10.1.12. The Previous Function">Section 10.1.12, “The Previous Function”</a>. That function accepts a relative (count) or absolute index and returns event properties or an event in the context of the specified data window.
				</p></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="view-std-firstunique"/>13.3.18. First Unique Window (<code class="literal">firstunique</code> or <code class="literal">std:firstunique</code>)</h3></div></div></div><a id="d0e35255" class="indexterm"/><a id="d0e35258" class="indexterm"/><p>
					The <code class="literal">firstunique</code> window retains only the very first among events having the same value for the specified expression or list of expressions.
				</p><p>
					The synopsis is:
				</p><pre class="synopsis">firstunique(<span class="emphasis"><em>unique_expression</em></span> [, <span class="emphasis"><em>unique_expression</em></span> ...])</pre><p>
					If used within a named window and an <code class="literal">on-delete</code> clause deletes events, the window resets and will retain the next arriving event for the expression result value(s) of the deleted events.
				</p><p>
					The below example creates a window that retains only the first event per category:
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select * from ReferenceData#firstunique(category)</pre><p>
					When using <code class="literal">firstunique</code> the engine plans queries applying an implicit unique index, where applicable. 
					Specify <code class="literal">@Hint('disable_unique_implicit_idx')</code> to force the engine to plan queries using a non-unique index.
				</p></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="view-ext-sort"/>13.3.19. Sorted Window (<code class="literal">sort</code> or <code class="literal">ext:sort</code>)</h3></div></div></div><a id="d0e35304" class="indexterm"/><a id="d0e35307" class="indexterm"/><p>					
					This window sorts by values returned by the specified expression or list of expressions and keeps only the top (or bottom) events up to the given size. 
				</p><p>					
					This window retains all events in the stream that fall into the sort range. Use the ranked window as described next to retain events per unique key(s) and sorted.
				</p><p>
					The syntax is as follows:
				</p><pre class="synopsis">sort(<span class="emphasis"><em>size_expression</em></span>, 
    <span class="emphasis"><em>sort_criteria_expression</em></span> [asc/desc][, <span class="emphasis"><em>sort_criteria_expression</em></span> [asc/desc]...]) </pre><p>					
					An expression may be followed by the optional <code class="literal">asc</code> or <code class="literal">desc</code> keywords to indicate that the values returned by that expression are sorted in ascending or descending sort order.
				</p><p>
					The window below retains only those events that have the highest 10 prices considering all events (and not only the last event per symbol, see rank below) and reports a total price:
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select sum(price) from StockTickEvent#sort(10, price desc)</pre><p>
					The following example sorts events first by price in descending order, and then by symbol name in ascending (alphabetical) order, keeping only the 10
events with the highest price (with ties resolved by alphabetical order of symbol).
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select * from StockTickEvent#sort(10, price desc, symbol asc)</pre><p>
					The sorted window is often used with the <code class="literal">prev</code>, <code class="literal">prevwindow</code> or <code class="literal">prevtail</code> single-row functions to output properties of events at a certain position or to output the complete data window according to sort order.
				</p><p>
					Use the grouped window to retain a separate sort window for each group. For example, the windows <code class="literal">groupwin(market)#sort(10, price desc)</code> instruct the engine to retain, per market,  the highest 10 prices.
				</p></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="view-ext-rank"/>13.3.20. Ranked Window (<code class="literal">rank</code> or <code class="literal">ext:rank</code>)</h3></div></div></div><a id="d0e35370" class="indexterm"/><a id="d0e35373" class="indexterm"/><p>					
					This window retains only the most recent among events having the same value for the criteria expression(s), sorted by sort criteria expressions and keeps only the top events up to the given size.
				</p><p>					
					This window is similar to the sorted window in that it keeps only the top (or bottom) events up to the given size, however the window also retains only the most recent among events having the same value(s) for the specified uniqueness expression(s).
				</p><p>
					The syntax is as follows:
				</p><pre class="synopsis">rank(<span class="emphasis"><em>unique_expression</em></span> [, <span class="emphasis"><em>unique_expression</em></span> ...],
    <span class="emphasis"><em>size_expression</em></span>, 
    <span class="emphasis"><em>sort_criteria_expression</em></span> [asc/desc][, <span class="emphasis"><em>sort_criteria_expression</em></span> [asc/desc]...]) </pre><p>
					Specify the expressions returning unique key values first. Then specify a constant value that is the size of the ranked window. Then specify the expressions returning sort criteria values. The sort criteria expressions may be followed by the optional <code class="literal">asc</code> or <code class="literal">desc</code> keywords to indicate that the values returned by that expression are sorted in ascending or descending sort order.
				</p><p>
					The window below retains only those events that have the highest 10 prices considering only the last event per symbol and reports a total price:
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select sum(price) from StockTickEvent#rank(symbol, 10, price desc)</pre><p>
					The following example retains, for the last event per market and symbol, those events that sort by price and quantity ascending into the first 10 ranks:
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select * from StockTickEvent#rank(market, symbol, 10, price, quantity)</pre><p>
					The ranked window is often used with the <code class="literal">prev</code>, <code class="literal">prevwindow</code> or <code class="literal">prevtail</code> single-row functions to output properties of events at a certain position or to output the complete data window according to sort order.
				</p><p>
					This example outputs every 5 seconds the top 10 events according to price descending and considering only the last event per symbol:
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select prevwindow(*) from StockTickEvent#rank(symbol, 10, price desc)
  output snapshot every 5 seconds limit 1  // need only 1 row</pre><p>
					Use the grouped window to retain a separate rank for each group. For example, the windows <code class="literal">groupwin(market)#rank(symbol, 10, price desc)</code> instruct the engine to retain, per market,  the highest 10 prices considering the last event per symbol.
				</p></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="view-time-order"/>13.3.21. Time-Order Window (<code class="literal">time_order</code> or <code class="literal">ext:time_order</code>)</h3></div></div></div><a id="d0e35446" class="indexterm"/><a id="d0e35449" class="indexterm"/><p>
					This window orders events that arrive out-of-order, using timestamp-values provided by an expression, and by comparing that timestamp value to engine time.
				</p><p>
					The syntax for this window is as follows.
				</p><pre class="synopsis">time_order(<span class="emphasis"><em>timestamp_expression</em></span>, <span class="emphasis"><em>time_period</em></span>)</pre><pre class="synopsis">time_order(<span class="emphasis"><em>timestamp_expression</em></span>, <span class="emphasis"><em>seconds_interval_expression</em></span>)</pre><p>
					The first parameter to the window is the expression that supplies timestamp values. The timestamp is expected to be a long-typed value that denotes an event's time of consideration by the window (or other expression). This is typically the time of arrival. The second parameter is a number-of-seconds expression or the time period specifying the time interval that an arriving event should maximally be held, in order to consider older events arriving at a later time.
				</p><p>
					Since the window compares timestamp values to engine time, the window requires that the timestamp values and engine time are both following the same clock. Therefore, to the extend that the clocks that originated both timestamps differ, the window may produce inaccurate results.
				</p><p>
					As an example, the next statement uses the <code class="literal">arrival_time</code> property of <code class="literal">MyTimestampedEvent</code> events to order and release events by arrival time:
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">insert rstream into ArrivalTimeOrderedStream
select rstream * from MyTimestampedEvent#time_order(arrival_time, 10 sec)</pre><p>
					In the example above, the <code class="literal">arrival_time</code> property holds a long-typed timestamp value. On arrival of an event, the engine compares the timestamp value of each event to the tail-time of the window. The tail-time of the window is, in this example, 10 seconds before engine time (continuously sliding). If the timestamp value indicates that the event is older then the tail-time of the time window, the event is released immediately in the remove stream. If the timestamp value indicates that the event is newer then the tail-time of the window, the window retains the event until engine time moves such that the event timestamp is older then tail-time.
				</p><p>
					The examples thus holds each arriving event in memory anywhere from zero seconds to 10 seconds, to allow for older events (considering arrival time timestamp) to arrive. In other words, the window holds an event with an arrival time equal to engine time for 10 seconds. The window holds an event with an arrival time that is 2 seconds older then engine time for 8 seconds. The window holds an event with an arrival time that is 10 or more seconds older then engine time for zero seconds, and releases such (old) events immediately into the remove stream. 
				</p><p>
					The insert stream of this sliding window consists of all arriving events. The remove stream of the window is ordered by timestamp value: The event that has the oldest timestamp value is released first, followed by the next newer events. Note the statement above uses the <code class="literal">rstream</code> keyword in both the <code class="literal">insert into</code> clause and the <code class="literal">select</code> clause to select ordered events only. It uses the <code class="literal">insert into</code> clause to makes such ordered stream available for subsequent statements to use.
				</p><p>
					It is up to your application to populate the timestamp property into your events or use a sensible expression that returns timestamp values for consideration by the window. The window also works well if you use externally-provided time via timer events. 
				</p></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="view-timetolive"/>13.3.22. Time-To-Live Window (<code class="literal">timetolive</code> or <code class="literal">ext:timetolive</code>)</h3></div></div></div><a id="d0e35520" class="indexterm"/><a id="d0e35523" class="indexterm"/><p>
					This window retains events until engine time reaches the value returned by the given timestamp expression.
				</p><p>
					The syntax for this window is as follows:
				</p><pre class="synopsis">timetolive(<span class="emphasis"><em>timestamp_expression</em></span>)</pre><p>
					The only parameter to the window is the expression that supplies timestamp values. The timestamp is expected to be a long-typed value that denotes an event's time-to-live. 
				</p><p>
					Since the window compares timestamp values to engine time, the window requires that the timestamp values and engine time are both following the same clock.
				</p><p>
					On arrival of an event, the engine evaluates the timestamp expression and obtains a long-type timestamp. The engine compares that timestamp value to engine time:
				</p><div class="itemizedlist"><ul><li><p>If the timestamp is older than engine time or the same as engine time, the engine releases the event immediately into the remove stream and does not retain the event at all.</p></li><li><p>If the timestamp value is newer than the engine time, the data window retains the event until engine time moves forward such that the timestamp is the same or older than engine time.</p></li></ul></div><p>
					As an example, the next statement uses the <code class="literal">arrival_time</code> property of <code class="literal">MyTimestampedEvent</code> events to release events by arrival time:
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">insert rstream into ArrivalTimeOrderedStream
select rstream * from MyTimestampedEvent#timetolive(arrival_time)</pre><p>
					For example, assume engine time is <code class="literal">8:00:00</code> (8 am).
				</p><div class="itemizedlist"><ul><li><p>
							If the <code class="literal">arrival_time</code> timestamp is <code class="literal">8:00:00</code> or older (such as <code class="literal">7:59:00</code>), the data window does not retain the event at all, i.e.
							the engine releases the event into the remove stream upon arrival.
						</p></li><li><p>
							If the <code class="literal">arrival_time</code> timestamp is after <code class="literal">8:00:00</code> the data window retains the event.
							Let's say the <code class="literal">arrival_time</code> timestamp is <code class="literal">8:02:00</code> the engine retains the event until engine time is <code class="literal">8:02:00</code> or newer.
						</p></li></ul></div><p>
					The engine evaluates the expression only once at the arrival of each event to determine that event's time-to-live.
				</p><p>
					The insert stream of this sliding window consists of all arriving events. The remove stream of the window is ordered by timestamp value: The event that has the oldest timestamp value is released first, followed by the next newer events. Note the statement above uses the <code class="literal">rstream</code> keyword in both the <code class="literal">insert into</code> clause and the <code class="literal">select</code> clause to select ordered events only. It uses the <code class="literal">insert into</code> clause to makes such ordered stream available for subsequent statements to use.
				</p><p>
					It is up to your application to populate the timestamp property into your events or use a sensible expression that returns timestamp values for consideration by the window. 
					The window also works well if you use externally-provided time via timer events and if you have engine time track watermarks. 
				</p><p>
					The time-to-live data window is fully equivalent to the time-order data window with a zero value for the time period.
				</p></div></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="stat-views"/>13.4. Special Derived-Value Windows</h2></div></div></div><p>
			   The derived-value windows can be used combined with data windows or alone. Very similar to aggregation functions, these windows aggregate or derive information from an event stream. As compared to aggregation functions,
			   statistics windows can post multiple derived fields all-in-one including properties from the last event that was received. The derived fields and event properties are available for querying in the <code class="literal">where</code>-clause and are often compared to prior values using the <code class="literal">prior</code> function. Derived-value window do not retain events.
           </p><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="view-std-size"/>13.4.1. Size Derived-Value Window (<code class="literal">size</code>) or <code class="literal">std:size</code>)</h3></div></div></div><a id="d0e35636" class="indexterm"/><a id="d0e35639" class="indexterm"/><p>
					This window posts the number of events received from a stream or window plus any additional event properties or expression values listed as parameters. The synopsis is:
				</p><pre class="synopsis">size([<span class="emphasis"><em>expression</em></span>, ...] [ * ])</pre><p>					
					The window posts a single long-typed property named <code class="literal">size</code>. The window posts the prior size as old data, and the current size as new data to update listeners of the window. Via the <code class="literal">iterator</code> method of the statement the size value can also be polled (read). The window only posts output events when the <code class="literal">size</code> count changes and does not stay the same.
				</p><p>
					As optional parameters the window takes a list of expressions that the window evaluates against the last arriving event and provides along the <code class="literal">size</code> field. You may also provide the <code class="literal">*</code> wildcard selector to have the window output all event properties.
				</p><p>					
					An alternative to receiving a data window event count is the <code class="literal">prevcount</code> function. Compared to the <code class="literal">size</code> window the <code class="literal">prevcount</code> function requires a data window while the <code class="literal">size</code> window does not. The related <code class="literal">count(...)</code> aggregation function provides a count per group when used with <code class="literal">group by</code>.
				</p><p>
					When combined with a data window, the size window  reports the current number of events in the data window in the insert stream and the prior number of events in the data window as the remove stream. This example reports the number of tick events within the last 1 minute:
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select size from StockTickEvent#time(1 min)#size</pre><p>
					To select additional event properties you may add each event property to output as a parameter to the window. 
				</p><p>
					The next example selects the symbol and feed event properties in addition to the <code class="literal">size</code> property:
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select size, symbol, feed from StockTickEvent#time(1 min)#size(symbol, feed)</pre><p>
					This example selects all event properties in addition to the <code class="literal">size</code> property:
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select * from StockTickEvent#time(1 min)#size(*)</pre><p>
					The size window is also useful in conjunction with a <code class="literal">groupwin</code> grouped-window to count the number of events per group. The EPL below returns the number of events per symbol.
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select size from StockTickEvent#groupwin(symbol)#size</pre><p>
					When used without a data window, the window simply counts the number of events:
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select size from StockTickEvent#size</pre><p>
					All windows can be used with pattern statements as well. The next EPL snippet shows a pattern that looks for tick events followed by trade events for the same symbol. The size window counts the number of occurrences of the pattern.
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select size from pattern[every s=StockTickEvent -&gt; TradeEvent(symbol=s.symbol)]#size</pre></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="view-stat-uni"/>13.4.2. Univariate Statistics Derived-Value Window (<code class="literal">uni</code> or <code class="literal">stat:uni</code>)</h3></div></div></div><a id="d0e35734" class="indexterm"/><a id="d0e35737" class="indexterm"/><p>
					This window calculates univariate statistics on a numeric expression. The window takes a single value expression as a parameter plus any number of optional additional expressions to return properties of the last event. The value expression must return a numeric value:
				</p><pre class="synopsis">uni(<span class="emphasis"><em>value_expression</em></span> [,<span class="emphasis"><em>expression</em></span>, ...] [ * ])</pre><p>
					After the value expression you may optionally list additional expressions or event properties to evaluate for the stream and return their value based on the last arriving event. You may also provide the <code class="literal">*</code> wildcard selector to have the window output all event properties.
				</p><div class="table"><a id="view-stat-uni-table"/><p class="title"><b>Table 13.5. Univariate Statistics Derived Properties</b></p><div class="table-contents"><table summary="Univariate Statistics Derived Properties" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Property Name</th><th>Description</th></tr></thead><tbody><tr><td><code class="literal">datapoints</code></td><td>Number of values, equivalent to <code class="literal">count(*)</code> for the stream</td></tr><tr><td><code class="literal">total</code></td><td>Sum of values</td></tr><tr><td><code class="literal">average</code></td><td>Average of values</td></tr><tr><td><code class="literal">variance</code></td><td>Variance</td></tr><tr><td><code class="literal">stddev</code></td><td>Sample standard deviation (square root of variance) </td></tr><tr><td><code class="literal">stddevpa</code></td><td>Population standard deviation</td></tr></tbody></table></div></div><br class="table-break"/><p>
					The below example selects the standard deviation on price for stock tick events for the last 10 events.
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select stddev from StockTickEvent#length(10)#uni(price)</pre><p>
					To add properties from the event stream you may simply add all additional properties as parameters to the window.
				</p><p>
					This example selects all of the derived values, based on the price property, plus the values of the symbol and feed event properties:
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select * from StockTickEvent#length(10)#uni(price, symbol, feed)</pre><p>
					The following example selects all of the derived values plus all event properties:
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select * from StockTickEvent#length(10)#uni(price, symbol, *)</pre></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="view-stat-linest"/>13.4.3. Regression Derived-Value Window (<code class="literal">linest</code> or <code class="literal">stat:linest</code>)</h3></div></div></div><a id="d0e35832" class="indexterm"/><a id="d0e35835" class="indexterm"/><p>
					This window calculates regression and related intermediate results on the values returned by two expressions. The window takes two value expressions as parameters plus any number of optional additional expressions to return properties of the last event. The value expressions must return a numeric value:
				</p><pre class="synopsis">linest(<span class="emphasis"><em>value_expression</em></span>, <span class="emphasis"><em>value_expression</em></span> [,<span class="emphasis"><em>expression</em></span>, ...] [ * ])</pre><p>
					After the two value expressions you may optionally list additional expressions or event properties to evaluate for the stream and return their value based on the last arriving event. You may also provide the <code class="literal">*</code> wildcard selector to have the window output all event properties.
				</p><div class="table"><a id="view-stat-linest-table"/><p class="title"><b>Table 13.6. Regression Derived Properties</b></p><div class="table-contents"><table summary="Regression Derived Properties" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Property Name</th><th>Description</th></tr></thead><tbody><tr><td><code class="literal">slope</code></td><td>Slope.</td></tr><tr><td><code class="literal">YIntercept</code></td><td>Y intercept.</td></tr><tr><td><code class="literal">XAverage</code></td><td>X average.</td></tr><tr><td><code class="literal">XStandardDeviationPop</code></td><td>X standard deviation population.</td></tr><tr><td><code class="literal">XStandardDeviationSample</code></td><td>X standard deviation sample.</td></tr><tr><td><code class="literal">XSum</code></td><td>X sum.</td></tr><tr><td><code class="literal">XVariance</code></td><td>X variance.</td></tr><tr><td><code class="literal">YAverage</code></td><td>X average.</td></tr><tr><td><code class="literal">YStandardDeviationPop</code></td><td>Y standard deviation population.</td></tr><tr><td><code class="literal">YStandardDeviationSample</code></td><td>Y standard deviation sample.</td></tr><tr><td><code class="literal">YSum</code></td><td>Y sum.</td></tr><tr><td><code class="literal">YVariance</code></td><td>Y variance.</td></tr><tr><td><code class="literal">dataPoints</code></td><td>Number of data points.</td></tr><tr><td><code class="literal">n</code></td><td>Number of data points.</td></tr><tr><td><code class="literal">sumX</code></td><td>Sum of X (same as X Sum).</td></tr><tr><td><code class="literal">sumXSq</code></td><td>Sum of X squared.</td></tr><tr><td><code class="literal">sumXY</code></td><td>Sum of X times Y.</td></tr><tr><td><code class="literal">sumY</code></td><td>Sum of Y (same as Y Sum).</td></tr><tr><td><code class="literal">sumYSq</code></td><td>Sum of Y squared.</td></tr></tbody></table></div></div><br class="table-break"/><p>
					The next example calculates regression and returns the slope and y-intercept on price and offer for all events in the last 10 seconds.
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select slope, YIntercept from StockTickEvent#time(10 seconds)#linest(price, offer)</pre><p>
					To add properties from the event stream you may simply add all additional properties as parameters to the window.
				</p><p>
					This example selects all of the derived values, based on the price and offer properties, plus the values of the symbol and feed event properties:
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select * from StockTickEvent#time(10 seconds)#linest(price, offer, symbol, feed)</pre><p>
					The following example selects all of the derived values plus all event properties:
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select * from StockTickEvent#time(10 seconds)#linest(price, offer, *)</pre></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="view-stat-correl"/>13.4.4. Correlation Derived-Value Window (<code class="literal">correl</code> or <code class="literal">stat:correl</code>)</h3></div></div></div><a id="d0e36008" class="indexterm"/><a id="d0e36011" class="indexterm"/><p>
					This window calculates the correlation value on the value returned by two expressions. The window takes two value expressions as parameters plus any number of optional additional expressions to return properties of the last event. The value expressions must be return a numeric value:
				</p><pre class="synopsis">correl(<span class="emphasis"><em>value_expression</em></span>, <span class="emphasis"><em>value_expression</em></span> [,<span class="emphasis"><em>expression</em></span>, ...] [ * ])</pre><p>
					After the two value expressions you may optionally list additional expressions or event properties to evaluate for the stream and return their value based on the last arriving event. You may also provide the <code class="literal">*</code> wildcard selector to have the window output all event properties.
				</p><div class="table"><a id="view-stat-correl-table"/><p class="title"><b>Table 13.7. Correlation Derived Properties</b></p><div class="table-contents"><table summary="Correlation Derived Properties" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Property Name</th><th>Description</th></tr></thead><tbody><tr><td><code class="literal">correlation</code></td><td>Correlation between two event properties</td></tr></tbody></table></div></div><br class="table-break"/><p>
					The next example calculates correlation on price and offer over all stock tick events for GE:
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select correlation from StockTickEvent(symbol='GE')#correl(price, offer)</pre><p>
					To add properties from the event stream you may simply add all additional properties as parameters to the window.
				</p><p>
					This example selects all of the derived values, based on the price and offer property, plus the values of the feed event property:
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select * from StockTickEvent(symbol='GE')#correl(price, offer, feed)</pre><p>
					The next example selects all of the derived values plus all event properties:
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select * from StockTickEvent(symbol='GE')#correl(price, offer, *)</pre></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="view-stat-weightedavg"/>13.4.5. Weighted Average Derived-Value Window (<code class="literal">weighted_avg</code> or <code class="literal">stat:weighted_avg</code>)</h3></div></div></div><a id="d0e36076" class="indexterm"/><a id="d0e36079" class="indexterm"/><p>
					This window returns the weighted average given an expression returning values to compute the average for and an expression returning weight. The window takes two value expressions as parameters plus any number of optional additional expressions to return properties of the last event. The value expressions must return numeric values:
				</p><pre class="synopsis">weighted_avg(<span class="emphasis"><em>value_expression_field</em></span>, <span class="emphasis"><em>value_expression_weight</em></span> [,<span class="emphasis"><em>expression</em></span>, ...] [ * ])</pre><p>
					After the value expression you may optionally list additional expressions or event properties to evaluate for the stream and return their value based on the last arriving event. You may also provide the <code class="literal">*</code> wildcard selector to have the window output all event properties.
				</p><div class="table"><a id="view-stat-weightedavg-table"/><p class="title"><b>Table 13.8. Weighted Average Derived Properties</b></p><div class="table-contents"><table summary="Weighted Average Derived Properties" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Property Name</th><th>Description</th></tr></thead><tbody><tr><td><code class="literal">average</code></td><td>Weighted average</td></tr></tbody></table></div></div><br class="table-break"/><p>
					A statement that derives the volume-weighted average price for the last 3 seconds for a given symbol is shown below:
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select average 
from StockTickEvent(symbol='GE')#time(3 seconds)#weighted_avg(price, volume)</pre><p>
					To add properties from the event stream you may simply add all additional properties as parameters to the window.
				</p><p>
					This example selects all of the derived values, based on the price and volume properties, plus the values of the symbol and feed event properties:
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select *
from StockTickEvent#time(3 seconds)#weighted_avg(price, volume, symbol, feed)</pre><p>
					The next example selects all of the derived values plus the values of all event properties:
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select *
from StockTickEvent#time(3 seconds)#weighted_avg(price, volume, *)</pre><p>
					Aggregation functions could instead be used to compute the weighted average as well. The next example also posts weighted average per symbol considering the last 3 seconds of stock tick data:
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select symbol, sum(price*volume)/sum(volume)
from StockTickEvent#time(3 seconds) group by symbol</pre><p>
					The following example computes weighted average keeping a separate data window per symbol considering the last 5 events of each symbol:
				</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select symbol, average
from StockTickEvent#groupwin(symbol)#length(5)#weighted_avg(price, volume)</pre></div></div></div><ul xmlns:d="http://docbook.org/ns/docbook" class="docnav"><li class="previous"><a accesskey="p" href="datetimereference.html"><strong>Prev</strong>Chapter 12. EPL Reference: Date-Time Methods</a></li><li class="up"><a accesskey="u" href="#"><strong>Top of page</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Front page</strong></a></li><li class="next"><a accesskey="n" href="api.html"><strong>Next</strong>Chapter 14. API Reference</a></li></ul></body></html>