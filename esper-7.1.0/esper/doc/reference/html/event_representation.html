<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">Chapter 3. Event Representations</title><link rel="stylesheet" href="css/espertech.css" type="text/css"/><meta xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL-NS Stylesheets V1.74.0"/><meta xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" http-equiv="Content-Type" content="text/html; charset=UTF-8"/><link rel="home" href="index.html" title="Esper Reference"/><link rel="up" href="index.html" title="Esper Reference"/><link rel="prev" href="processingmodel.html" title="Chapter 2. Basic Concepts"/><link rel="next" href="context.html" title="Chapter 4. Context and Context Partitions"/></head><body><p xmlns:d="http://docbook.org/ns/docbook" id="title"><a href="http://www.espertech.com" class="site_href"><strong>www.espertech.com</strong></a><a href="http://www.espertech.com/esper/documentation.php" class="doc_href"><strong>Documentation</strong></a></p><ul xmlns:d="http://docbook.org/ns/docbook" class="docnav"><li class="previous"><a accesskey="p" href="processingmodel.html"><strong>Prev</strong></a></li><li class="next"><a accesskey="n" href="context.html"><strong>Next</strong></a></li></ul><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="event_representation"/>Chapter 3. Event Representations</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="event_representation.html#eventrep_intro">3.1. Event Underlying Java Objects</a></span></dt><dt><span class="sect1"><a href="event_representation.html#eventrep-properties">3.2. Event Properties</a></span></dt><dd><dl><dt><span class="sect2"><a href="event_representation.html#eventrep-properties-escaping">3.2.1. Escape Characters</a></span></dt><dt><span class="sect2"><a href="event_representation.html#eventrep-properties-expression">3.2.2. Expression as Key or Index Value</a></span></dt></dl></dd><dt><span class="sect1"><a href="event_representation.html#eventrep-dyncproperties">3.3. Dynamic Event Properties</a></span></dt><dt><span class="sect1"><a href="event_representation.html#eventrep-fragment">3.4. Fragment and Fragment Type</a></span></dt><dt><span class="sect1"><a href="event_representation.html#eventrep_comparing">3.5. Comparing Event Representations</a></span></dt><dd><dl><dt><span class="sect2"><a href="event_representation.html#eventrep_comparing_incoming">3.5.1. Incoming Events</a></span></dt><dt><span class="sect2"><a href="event_representation.html#eventrep_comparing_outgoing">3.5.2. Outgoing Events</a></span></dt><dt><span class="sect2"><a href="event_representation.html#eventrep_comparing_schema">3.5.3. Schema</a></span></dt><dt><span class="sect2"><a href="event_representation.html#eventrep_comparing_advantages">3.5.4. Side-by-Side</a></span></dt></dl></dd><dt><span class="sect1"><a href="event_representation.html#eventrep-generictuple">3.6. Support for Generic Tuples</a></span></dt><dt><span class="sect1"><a href="event_representation.html#eventrep-plug-in">3.7. Additional Event Representations</a></span></dt><dt><span class="sect1"><a href="event_representation.html#eventrep-update">3.8. Updating, Merging and Versioning Events</a></span></dt><dt><span class="sect1"><a href="event_representation.html#eventrep-coarse">3.9. Coarse-Grained Events</a></span></dt><dt><span class="sect1"><a href="event_representation.html#eventrep-insertinto">3.10. Event Objects Instantiated and Populated by Insert Into</a></span></dt></dl></div><p>
		This section outlines the different means to model and represent events.
    </p><p>
		Esper uses the term <span class="emphasis"><em>event type</em></span> to describe the type information available for an event representation.
	</p><p>
	    Your application may configure predefined event types at startup time or dynamically add event types at runtime via API or EPL syntax. See <a class="xref" href="configuration.html#configuration-items" title="15.4. Configuration Items">Section 15.4, “Configuration Items”</a> for startup-time configuration and <a class="xref" href="api.html#api-admin-runtime-config" title="14.3.8. Runtime Configuration">Section 14.3.8, “Runtime Configuration”</a> for the runtime configuration API.
	</p><p>
	    The EPL <code class="literal">create schema</code> syntax allows declaring an event type at runtime using EPL, see <a class="xref" href="epl_clauses.html#epl_createschema" title="5.15. Declaring an Event Type: Create Schema">Section 5.15, “Declaring an Event Type: Create Schema”</a>.
	</p><p>
		<a class="xref" href="api.html#api-event" title="14.6. Event and Event Type">Section 14.6, “Event and Event Type”</a> explains how an event type becomes visible in EPL statements and output events delivered by the engine.
    </p><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="eventrep_intro"/>3.1. Event Underlying Java Objects</h2></div></div></div><a id="d0e2076" class="indexterm"/><p>
			An event is an immutable record of a past occurrence of an action or state change. Event properties capture the state information for an event.
        </p><p>
			In Esper, an event can be represented by any of the following underlying Java objects (NEsper .NET, see <a class="xref" href="appendix_dotnet.html#appendix_dotnet_eventrep_intro" title="I.6. .NET Event Underlying Objects">Section I.6, “.NET Event Underlying Objects”</a>):
        </p><div class="table"><a id="d0e2087"/><p class="title"><b>Table 3.1. Event Underlying Java Objects</b></p><div class="table-contents"><table summary="Event Underlying Java Objects" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Java Class</th><th>Description</th></tr></thead><tbody><tr><td><code class="literal">java.lang.Object</code></td><td>Any Java POJO (plain-old java object) with getter methods following JavaBean conventions;  Legacy Java classes not following JavaBean conventions can also serve as events .</td></tr><tr><td><code class="literal">java.util.Map</code></td><td>Map events are implementations of the <code class="literal">java.util.Map</code> interface where each map entry is a propery value.</td></tr><tr><td><code class="literal">Object[] (array of object)</code></td><td>Object-array events are arrays of objects (type <code class="literal">Object[]</code>) where each array element is a property value.</td></tr><tr><td><code class="literal">org.apache.avro.generic.GenericData.Record</code></td><td>Apache Avro events are <code class="literal">GenericData.Record</code> objects (Avro is a data serialization system with JSON and schema support)</td></tr><tr><td><code class="literal">org.w3c.dom.Node</code></td><td>XML document object model (DOM).</td></tr><tr><td><code class="literal">org.apache.axiom.om.OMDocument or OMElement</code></td><td>XML - Streaming API for XML (StAX) - Apache Axiom (provided by EsperIO package).</td></tr><tr><td>Application classes</td><td>Plug-in event representation via the extension API.</td></tr></tbody></table></div></div><br class="table-break"/><p>
			Esper provides multiple choices for representing an event. There is no absolute need for you to create new Java classes to represent an event.
		</p><p>
			Event representations have the following in common:
		</p><div class="itemizedlist"><ul compact="compact"><li><p>
					All event representations support nested, indexed and mapped properties (aka. property expression), as explained in more detail below. There is no limitation to the nesting level.
				</p></li><li><p>
					All event representations provide event type metadata. This includes type metadata for nested properties.
				</p></li><li><p>
					All event representations allow transposing the event itself and parts or all of its property graph into new events. The term transposing refers to selecting the event itself or event properties that are themselves nestable property graphs, and then querying the event's properties or nested property graphs in further statements. The Apache Axiom event representation is an exception and does not currently allow transposing event properties but does allow transposing the event itself.
				</p></li><li><p>
					The Java object, Map, Object-array and Avro representations allow supertypes.
				</p></li></ul></div><p>
			The API behavior for all event representations is the same, with minor exceptions noted. 
		</p><p>
			The benefits of multiple event representations are:
		</p><div class="itemizedlist"><ul compact="compact"><li><p>
					For applications that already have events in one of the supported representations, there is no need to transform events before processing for both input and output.
				</p></li><li><p>
					Event representations are exchangeable, reducing or eliminating the need to change statements when the event representation changes, i.e. the EPL does not depend on whether events are Objects, Map(s), Object-array(s), Avro record(s) or XML document(s).
				</p></li><li><p>
					Event representations are interoperable, allowing all event representations to interoperate in same or different statements.
				</p></li><li><p>
					The choice makes it possible to consciously trade-off performance, ease-of-use, the ability to evolve and effort needed to import or externalize events and use existing event type metadata. 
				</p></li></ul></div></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="eventrep-properties"/>3.2. Event Properties</h2></div></div></div><a id="d0e2187" class="indexterm"/><p>
			 Event properties capture the state information for an event. Event properties can be simple, indexed, mapped and nested event properties.
		</p><p>
			 The table below outlines the different types of properties and their syntax in an event expression:
		</p><div class="table"><a id="d0e2196"/><p class="title"><b>Table 3.2. Types of Event Properties</b></p><div class="table-contents"><table summary="Types of Event Properties" border="1"><colgroup><col/><col/><col/><col/></colgroup><thead><tr><th>Type</th><th>Description</th><th>Syntax</th><th>Example</th></tr></thead><tbody><tr><td>Simple</td><td>A property that has a single value that may be retrieved.</td><td><pre class="synopsis">name</pre></td><td><pre class="synopsis">sensorId</pre></td></tr><tr><td>Indexed</td><td>An indexed property stores an ordered collection of objects (all of the same type) that can be individually accessed by an integer-valued, non-negative index (or subscript).</td><td><pre class="synopsis">name[<span class="emphasis"><em>index</em></span>]</pre></td><td><pre class="synopsis">temperature[0]</pre></td></tr><tr><td>Mapped</td><td>A mapped property stores a keyed collection of objects (all of the same type).</td><td><pre class="synopsis">name('<span class="emphasis"><em>key</em></span>')</pre></td><td><pre class="synopsis">isTurnedOn('light')</pre></td></tr><tr><td>Nested</td><td>A nested property is a property that lives within another property of an event.</td><td><pre class="synopsis">name.nestedname</pre></td><td><pre class="synopsis">sensor.value</pre></td></tr></tbody></table></div></div><br class="table-break"/><p>
			Combinations are also possible. For example, a valid combination could be <code class="literal">person.address('home').street[0]</code>.
		</p><p>
			You may use any expression as a mapped property key or indexed property index by putting the expression within parenthesis after the mapped or index property name. Please find examples below.
		</p><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="eventrep-properties-escaping"/>3.2.1. Escape Characters</h3></div></div></div><p>
				If your application uses <code class="literal">java.util.Map</code>, <code class="literal">Object[]</code> (object-array) or XML to represent events, then event property names may themselves contain the dot ('.') character. The backslash ('\') character can be used to escape dot characters in property names, allowing a property name to contain dot characters. 
			</p><p>
				For example, the EPL as shown below expects a property by name <code class="literal">part1.part2</code> to exist on event type <code class="literal">MyEvent</code>:
			</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select part1\.part2 from MyEvent</pre><p>
				Sometimes your event properties may overlap with EPL language keywords or contain spaces or other special characters. In this case you may use the backwards apostrophe <code class="literal">`</code> (aka. back tick) character to escape the property name.
			</p><p>
				The next example assumes a <code class="literal">Quote</code> event that has a property by name <code class="literal">order</code>, while <code class="literal">order</code> is also a reserved keyword:
			</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select `order`, price as `price.for.goods` from Quote</pre><p>
				When escaping mapped or indexed properties, make sure the back tick character appears outside of the map key or index.
			</p><p>
				The next EPL selects event properties that have names that contain spaces (e.g. <code class="literal">candidate book</code>), have the tick special character  (e.g. <code class="literal">children's books</code>), are an indexed property (e.g. <code class="literal">children's books[0]</code>) and a mapped property 
				that has a reserved keyword as part of the property name (e.g. <code class="literal">book select('isbn')</code>):
			</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select `candidate book` , `children's books`[0], `book select`('isbn') from MyEventType</pre><div xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>
					Avro does not support the dot-character in field names.
				</p></div></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="eventrep-properties-expression"/>3.2.2. Expression as Key or Index Value</h3></div></div></div><p>
				The key or index expression must be placed in parenthesis.  When using an expression as key for a mapped property, the expression must return a <code class="literal">String</code>-typed value. When using an expression as index for an indexed property, the expression must return an <code class="literal">int</code>-typed value.				
			</p><p>
				This example below uses Java classes to illustrate; The same principles apply to all event representations.
			</p><p>
				Assume a class declares these properties (getters not shown for brevity):
			</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">public class MyEventType {
  String myMapKey;
  int myIndexValue;
  int myInnerIndexValue;
  Map&lt;String, InnerType&gt; innerTypesMap;	// mapped property
  InnerType[] innerTypesArray; // indexed property
}

public class InnerType {
  String name;
  int[] ids;
}</pre><p>
				A sample EPL statement demonstrating expressions as map keys or indexes is:
			</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select innerTypesMap('somekey'),  // returns map value for 'somekey'
  innerTypesMap(myMapKey),        // returns map value for myMapKey value (an expression)
  innerTypesArray[1],             // returns array value at index 1
  innerTypesArray(myIndexValue)   // returns array value at index myIndexValue (an expression)
  from MyEventType</pre><p>
				The dot-operator can be used to access methods on the value objects returned by the mapped or indexed properties. By using the dot-operator the syntax follows the chained method invocation described at <a class="xref" href="epl-operator.html#epl-operator-ref-dot" title="9.6. Dot Operator">Section 9.6, “Dot Operator”</a>.
			</p><p>
				A sample EPL statement demonstrating the dot-operator as well as expressions as map keys or indexes is:
			</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class=""> select innerTypesMap('somekey').ids[1],
  innerTypesMap(myMapKey).getIds(myIndexValue),
  innerTypesArray[1].ids[2],
  innerTypesArray(myIndexValue).getIds(myInnerIndexValue)
  from MyEventType</pre><p>
				Please note the following limitations:
			</p><div class="itemizedlist"><ul compact="compact"><li><p>
						The square brackets-syntax for indexed properties does now allow expressions and requires a constant index value.
					</p></li><li><p>
						When using the dot-operator with mapped or indexed properties that have expressions as map keys or indexes you must follow the chained method invocation syntax.
					</p></li></ul></div></div></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="eventrep-dyncproperties"/>3.3. Dynamic Event Properties</h2></div></div></div><a id="d0e2373" class="indexterm"/><a id="d0e2376" class="indexterm"/><p>
			Dynamic (unchecked) properties are event properties that need not be known at statement compilation time. Such properties are resolved during runtime: they provide duck typing functionality.
		</p><p>
			The idea behind dynamic properties is that for a given underlying event representation you don't always know all properties in advance. An underlying event may have additional properties that are not known at statement compilation time, that you want to query on. The concept is especially useful for events that represent rich, object-oriented domain models.
		</p><p>
			The syntax of dynamic properties consists of the property name and a question mark. Indexed, mapped and nested properties can also be dynamic properties:
		</p><div class="table"><a id="d0e2387"/><p class="title"><b>Table 3.3. Types of Event Properties</b></p><div class="table-contents"><table summary="Types of Event Properties" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Type</th><th>Syntax</th></tr></thead><tbody><tr><td>Dynamic Simple</td><td><pre class="synopsis">name?</pre></td></tr><tr><td>Dynamic Indexed</td><td><pre class="synopsis">name[<span class="emphasis"><em>index</em></span>]?</pre></td></tr><tr><td>Dynamic Mapped</td><td><pre class="synopsis">name('<span class="emphasis"><em>key</em></span>')?</pre></td></tr><tr><td>Dynamic Nested</td><td><pre class="synopsis">name?.nestedPropertyName</pre></td></tr></tbody></table></div></div><br class="table-break"/><p>
			 Dynamic properties always return the <code class="literal">java.lang.Object</code> type. Also, dynamic properties return a <code class="literal">null</code> value if the dynamic property does not exist on events processed at runtime. 
		</p><p>
			As an example, consider an OrderEvent event that provides an "item" property. The "item" property is of type <code class="literal">Object</code> and holds a reference to an instance of either a Service or Product. 
		</p><p>
			Assume that both Service and Product classes provide a property named "price". Via a dynamic property you can specify a query that obtains the price property from either object (Service or Product):
		</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select item.price? from OrderEvent</pre><p>
			 As a second example, assume that the Service class contains a "serviceName" property that the Product class does not possess. The following query returns the value of the "serviceName" property for Service objects. It returns a <code class="literal">null</code>-value for Product objects that do not have the "serviceName" property:
		</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select item.serviceName? from OrderEvent</pre><p>
			Consider the case where OrderEvent has multiple implementation classes, some of which have a "timestamp" property. The next query returns the timestamp property of those implementations of the OrderEvent interface that feature the property:
		</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select timestamp? from OrderEvent</pre><p>
			The query as above returns a single column named "timestamp?" of type <code class="literal">Object</code>. 			
		</p><p>
			When dynamic properties are nested, then all properties under the dynamic property are also considered dynamic properties. In the below example the query asks for the "direction" property of the object returned by the "detail" dynamic property:
		</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select detail?.direction from OrderEvent</pre><p>
			Above is equivalent to:
		</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select detail?.direction? from OrderEvent</pre><p>
			The functions that are often useful in conjunction with dynamic properties are:
		</p><div class="itemizedlist"><ul><li><p>
                    The <code class="literal">cast</code> function casts the value of a dynamic property (or the value of an expression) to a given type.
                </p></li><li><p>
                    The <code class="literal">exists</code> function checks whether a dynamic property exists. It returns <code class="literal">true</code> if the event has a property of that name, or false if the property does not exist on that event.
                </p></li><li><p>
                    The <code class="literal">instanceof</code> function checks whether the value of a dynamic property (or the value of an expression) is of any of the given types.
                </p></li><li><p>
                    The <code class="literal">typeof</code> function returns the string type name of a dynamic property.
                </p></li></ul></div><p>
			Dynamic event properties work with all event representations outlined next: Java objects, Map-based, Object-array-based and XML DOM-based events.
		</p></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="eventrep-fragment"/>3.4. Fragment and Fragment Type</h2></div></div></div><p>
			Sometimes an event can have properties that are itself events. Esper uses the term <span class="emphasis"><em>fragment</em></span> and <span class="emphasis"><em>fragment type</em></span> for such event pieces. The best example is a pattern
			that matches two or more events and the output event contains the matching events as fragments. In other words, output events can be a composite event that consists of further events, the fragments.
		</p><p>
			Fragments have the same metadata available as their enclosing composite events. The metadata for enclosing composite events contains information about which properties are fragments, or have a property value that can be 
			represented as a fragment and therefore as an event itself.
		</p><p>
			Fragments and type metadata can allow your application to navigate composite events without the need for using the Java reflection API and reducing the coupling to the underlying event representation.
			The API is further described in <a class="xref" href="api.html#api-event" title="14.6. Event and Event Type">Section 14.6, “Event and Event Type”</a>.
		</p></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="eventrep_comparing"/>3.5. Comparing Event Representations</h2></div></div></div><p>
			More information on event representations can be found in the appendix. The links are:
		</p><div class="table"><a id="d0e2525"/><p class="title"><b>Table 3.4. Comparing Event Representations</b></p><div class="table-contents"><table summary="Comparing Event Representations" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Event Representation</th><th>More Information and Examples</th></tr></thead><tbody><tr><td>Java Object (POJO/Bean or other)</td><td><a class="xref" href="appendix_eventrepbean.html" title="Appendix D. Event Representation: Plain-Old Java Object Events">Appendix D, <i>Event Representation: Plain-Old Java Object Events</i></a></td></tr><tr><td>Map</td><td><a class="xref" href="appendix_eventrepmap.html" title="Appendix E. Event Representation: java.util.Map Events">Appendix E, <i>Event Representation: java.util.Map Events</i></a></td></tr><tr><td>Object-array</td><td><a class="xref" href="appendix_eventrepoa.html" title="Appendix F. Event Representation: Object-Array (Object[]) Events">Appendix F, <i>Event Representation: Object-Array (Object[]) Events</i></a></td></tr><tr><td>Avro</td><td><a class="xref" href="appendix_eventrepavro.html" title="Appendix G. Event Representation: Avro Events (org.apache.avro.generic.GenericData.Record)">Appendix G, <i>Event Representation: Avro Events (org.apache.avro.generic.GenericData.Record)</i></a></td></tr><tr><td>XML Document</td><td><a class="xref" href="appendix_eventrepxml.html" title="Appendix H. Event Representation: org.w3c.dom.Node XML Events">Appendix H, <i>Event Representation: org.w3c.dom.Node XML Events</i></a></td></tr></tbody></table></div></div><br class="table-break"/><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="eventrep_comparing_incoming"/>3.5.1. Incoming Events</h3></div></div></div><p>
				For sending incoming events into the engine for processing, your application uses one of the send-event methods on the <code class="literal">EPRuntime</code> interface: 
			</p><div class="table"><a id="d0e2571"/><p class="title"><b>Table 3.5. EPRuntime Send-event Methods</b></p><div class="table-contents"><table summary="EPRuntime Send-event Methods" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Event Representation</th><th>Method for Processing Events</th></tr></thead><tbody><tr><td>Java Object (POJO/Bean or other)</td><td><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">sendEvent(Object event)</pre></td></tr><tr><td>Map</td><td><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">sendEvent(Map map, String mapEventTypeName)</pre></td></tr><tr><td>Object-array</td><td><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">sendEvent(Object[] objectarray, String objectArrayEventTypeName)</pre></td></tr><tr><td>Avro</td><td><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">sendEvent(Object avroGenericDataDotRecord, String avroEventTypeName)</pre></td></tr><tr><td>XML Document</td><td><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">sendEvent(org.w3c.dom.Node node)</pre></td></tr></tbody></table></div></div><br class="table-break"/><p>
				Please find an example in the respective appendix.
			</p></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="eventrep_comparing_outgoing"/>3.5.2. Outgoing Events</h3></div></div></div><p>
				The <code class="literal">StatementUpdateListener</code> interface receives EPL statement output. The output events can be either of the representations
			</p><div class="table"><a id="d0e2624"/><p class="title"><b>Table 3.6. Annotation for Receiving Events</b></p><div class="table-contents"><table summary="Annotation for Receiving Events" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Event Representation</th><th>Annotation</th></tr></thead><tbody><tr><td>Java Object (POJO/Bean or other)</td><td><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">N/A</pre></td></tr><tr><td>Map</td><td><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">@EventRepresentation(map)</pre></td></tr><tr><td>Object-array</td><td><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">@EventRepresentation(objectarray)</pre></td></tr><tr><td>Avro</td><td><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">@EventRepresentation(avro)</pre></td></tr><tr><td>XML Document</td><td><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">N/A</pre></td></tr></tbody></table></div></div><br class="table-break"/><p>
				Please find an example in the respective appendix.
			</p></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="eventrep_comparing_schema"/>3.5.3. Schema</h3></div></div></div><p>
				The create-schema clause can be used to define an event type and its event representation.
			</p><div class="table"><a id="d0e2674"/><p class="title"><b>Table 3.7. Create-Schema</b></p><div class="table-contents"><table summary="Create-Schema" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Event Representation</th><th>Annotation</th></tr></thead><tbody><tr><td>Java Object (POJO/Bean or other)</td><td><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">create schema <span xmlns="http://www.w3.org/1999/xhtml" class="emphasis"><em>name</em></span> as <span xmlns="http://www.w3.org/1999/xhtml" class="emphasis"><em>class_name</em></span></pre></td></tr><tr><td>Map</td><td><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">create map schema <span xmlns="http://www.w3.org/1999/xhtml" class="emphasis"><em>name</em></span> as (...)</pre></td></tr><tr><td>Object-array</td><td><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">create objectarray schema <span xmlns="http://www.w3.org/1999/xhtml" class="emphasis"><em>name</em></span> as (...)</pre></td></tr><tr><td>Avro</td><td><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">create avro schema <span xmlns="http://www.w3.org/1999/xhtml" class="emphasis"><em>name</em></span> as (...)</pre></td></tr><tr><td>XML Document</td><td><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">N/A</pre></td></tr></tbody></table></div></div><br class="table-break"/><p>
				Your EPL statements can use <code class="literal">create schema</code> and <code class="literal">insert into</code> to define an event type and to produce events of the type.
			</p><p>
				In the following example the first statement declares a schema and the second statement inserts events according to the schema:
			</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">create map schema ParkingEvent as (carId string, driverName string)</pre><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">insert into ParkingEvent select carId, 'jim' as driverName from CarArrivalEvent</pre><p>
				Please find additional examples in <a class="xref" href="epl_clauses.html#epl_createschema" title="5.15. Declaring an Event Type: Create Schema">Section 5.15, “Declaring an Event Type: Create Schema”</a>.
			</p></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="eventrep_comparing_advantages"/>3.5.4. Side-by-Side</h3></div></div></div><p>
				Each of the event representations of Java object, Map, Object-array, Avro and XML document has advantages and disadvantages that are summarized in the table below:
			</p><div class="table"><a id="d0e2754"/><p class="title"><b>Table 3.8. Comparing Event Representations</b></p><div class="table-contents"><table summary="Comparing Event Representations" border="1"><colgroup><col/><col/><col/><col/><col/><col/></colgroup><thead><tr><th> </th><th>Java Object (POJO/Bean or other)</th><th>Map</th><th>Object-array</th><th>Avro</th><th>XML Document</th></tr></thead><tbody><tr><td>Performance</td><td>Very Good (with Byte Code Generation, else Good)</td><td>Good</td><td>Very Good</td><td>Very Good</td><td>Not comparable and depending on use of XPath</td></tr><tr><td>Memory Use</td><td>Small</td><td>Medium</td><td>Small</td><td>Small</td><td>Depends on DOM and XPath implementation used, can be large</td></tr><tr><td>Call Method on Event</td><td>Yes</td><td>Yes, if contains Object(s)</td><td>Yes, if contains Object(s)</td><td>No</td><td>No</td></tr><tr><td>Nested, Indexed, Mapped and Dynamic Properties</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>Course-grained event syntax</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>Insert-into that Representation</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>No</td></tr><tr><td>Runtime Type Change</td><td>Reload class, yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>Create-schema Syntax</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>No, runtime and static configuration</td></tr><tr><td>Object is Self-Descriptive</td><td>Yes</td><td>Yes</td><td>No</td><td>Yes</td><td>Yes</td></tr><tr><td>Supertypes</td><td>Multiple</td><td>Multiple</td><td>Single</td><td>Single</td><td>No</td></tr></tbody></table></div></div><br class="table-break"/></div></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="eventrep-generictuple"/>3.6. Support for Generic Tuples</h2></div></div></div><p>
			   Esper does not require a fixed tuple structure and fully supports generic tuples. Event properties can be defined, added to existing types and queried at runtime.
		   </p><p>
			 The facilities for support of generic tuples are:  
		   </p><div class="itemizedlist"><ul><li><p>Dynamic properties allow querying properties that are not defined, see <a class="xref" href="event_representation.html#eventrep-dyncproperties" title="3.3. Dynamic Event Properties">Section 3.3, “Dynamic Event Properties”</a>.</p></li><li><p>The <code class="literal">cast</code> function for operations that require strongly-typed data, see <a class="xref" href="functionreference.html#epl-single-row-function-cast" title="10.1.2. The Cast Function">Section 10.1.2, “The Cast Function”</a>.</p></li><li><p>Type inheritance for adding properties to supertypes, see <a class="xref" href="epl_clauses.html#epl_createschema" title="5.15. Declaring an Event Type: Create Schema">Section 5.15, “Declaring an Event Type: Create Schema”</a></p></li><li><p>The Map event representation, as it allows any map key to become an event property, see <a class="xref" href="appendix_eventrepmap.html" title="Appendix E. Event Representation: java.util.Map Events">Appendix E, <i>Event Representation: java.util.Map Events</i></a></p></li><li><p>The Avro event representation, as it allows any Avro field to become an event property, see <a class="xref" href="appendix_eventrepavro.html" title="Appendix G. Event Representation: Avro Events (org.apache.avro.generic.GenericData.Record)">Appendix G, <i>Event Representation: Avro Events (org.apache.avro.generic.GenericData.Record)</i></a></p></li><li><p>The POJO event representation, as getter-methods and fields can be dynamically discovered to become an event property, see <a class="xref" href="appendix_eventrepbean.html" title="Appendix D. Event Representation: Plain-Old Java Object Events">Appendix D, <i>Event Representation: Plain-Old Java Object Events</i></a></p></li><li><p>The XML event representation, as the DOM can have any attribute or nested element and there does not need to be a schema, see <a class="xref" href="appendix_eventrepxml.html" title="Appendix H. Event Representation: org.w3c.dom.Node XML Events">Appendix H, <i>Event Representation: org.w3c.dom.Node XML Events</i></a></p></li><li><p>Event types can be updated at runtime using the API</p></li></ul></div><p>
				There is no need to explicitly create an event type for each tuple type. It is not necessary to create classes for tuple types at all. Events can be arbitrary objects.
			</p><p>
				The engine validates EPL at statement creation time therefore there is an advantage if type information is available: the engine can verify your EPL statement against the known properties and types,
				preventing you as the EPL designer from making mistakes in EPL design.
				The engine does not verify dynamic properties, which may return <code class="literal">null</code> at runtime. 
				If type information is not available then properties are assumed to return <code class="literal">java.lang.Object</code>-typed values.
			</p><p>
				For example, let's say you need a generic tuple and you have <code class="literal">Map</code> events:
			</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">create schema GenericTuple()</pre><p>
				Create statements that use dynamic properties, as the next EPL shows, which casts the timestamp value to a <code class="literal">long</code>-type value and outputs the hour-minute-second string:
			</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">select cast(timestamp?, long).format('hh mm ss') from GenericTuple</pre><p>
				Send events like this:
			</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">Map&lt;String, Object&gt; genericEvent = new HashMap&lt;&gt;();
genericEvent.put("timestamp", new Date().getTime());
genericEvent.put("some_other_property", "hello");
epService.getEPRuntime().sendEvent(genericEvent, "GenericTuple");</pre></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="eventrep-plug-in"/>3.7. Additional Event Representations</h2></div></div></div><a id="d0e2983" class="indexterm"/><p>
		    Part of the extension and plug-in features of Esper is an event representation API. This set of classes allow an application to create new event types and event instances based on information available elsewhere, statically or dynamically at runtime when EPL statements are created. Please see <a class="xref" href="extension.html#custom-event-representation" title="17.8. Event Type and Event Object">Section 17.8, “Event Type and Event Object”</a> for details.
		</p><p>
			Creating a plug-in event representation can be useful when your application has existing Java classes that carry event metadata and event property values and your application does not want to (or cannot) extract or transform
such event metadata and event data into one of the built-in event representations (POJO Java objects, Map, Object-array or XML DOM).
		</p><p>
			Further use of a plug-in event representation is to provide a faster or short-cut access path to event data. For example, access to event data stored in a XML format through the Streaming API for XML (StAX) is known to be very efficient. A plug-in event representation can also provide network lookup and dynamic resolution of event type and dynamic sourcing of event instances.
		</p><p>
			Currently, EsperIO provides the following additional event representations:
		</p><div class="itemizedlist"><ul compact="compact"><li><p>
					Apache Axiom: Streaming API for XML (StAX) implementation
				</p></li></ul></div><p>
			Please see the EsperIO documentation for details on the above.
		</p><p>
			The chapter on <a class="xref" href="extension.html#custom-event-representation" title="17.8. Event Type and Event Object">Section 17.8, “Event Type and Event Object”</a> explains how to create your own custom event representation.
		</p></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="eventrep-update"/>3.8. Updating, Merging and Versioning Events</h2></div></div></div><a id="d0e3011" class="indexterm"/><a id="d0e3016" class="indexterm"/><p>
			To summarize, an event is an immutable record of a past occurrence of an action or state change, and event properties contain useful information about an event.
        </p><p>
			The length of time an event is of interest to the event processing engine (retention time) depends on your EPL statements, and especially the data window, pattern and output rate 
			limiting clauses of your statements.
        </p><p>
			During the retention time of an event more information about the event may become available, such as additional properties or changes to existing properties. 
			Esper provides three concepts for handling updates to events.
        </p><p>
			  The first means to handle updating events is the <code class="literal">update istream</code> clause as further described in <a class="xref" href="epl_clauses.html#epl-update" title="5.20. Updating an Insert Stream: The Update IStream Clause">Section 5.20, “Updating an Insert Stream: The Update IStream Clause”</a>. It is useful when you need to update events as they enter a stream, before events are evaluated by any particular 
			  consuming statement to that stream.
        </p><p>
			  The second means to update events is the <code class="literal">on-merge</code> and <code class="literal">on-update</code> clauses, for use with tables and named windows only, as further described in <a class="xref" href="nwtable.html#named_upsert" title="6.8. Triggered Upsert Using the On-Merge Clause">Section 6.8, “Triggered Upsert Using the On-Merge Clause”</a> and <a class="xref" href="nwtable.html#named_update" title="6.6. Updating Data: The On Update Clause">Section 6.6, “Updating Data: The On Update Clause”</a>. On-merge
			  is similar to the SQL <code class="literal">merge</code> clause and provides what is known as an "Upsert" operation: Update existing events or if no existing event(s) are found then insert a new event, all in one atomic operation provided by a single EPL statement. 
			  On-update can be used to update individual properties of rows held in a table or named window.
        </p><p>
			  The third means to handle updating events is the revision event types, for use with named windows only, as further described in <a class="xref" href="nwtable.html#named_versioning" title="6.11. Versioning and Revision Event Type Use With Named Windows">Section 6.11, “Versioning and Revision Event Type Use With Named Windows”</a>. With revision event types you can declare, via configuration only, multiple different event types. The engine can present a merged event type that contains a superset of properties of all merged types, and the engine can merge events as they arrive without additional EPL statements.
        </p></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="eventrep-coarse"/>3.9. Coarse-Grained Events</h2></div></div></div><a id="d0e3056" class="indexterm"/><a id="d0e3061" class="indexterm"/><p>
			Your application events may consist of fairly comprehensive, coarse-grained structures or documents. For example in business-to-business integration scenarios, XML documents or other event objects can be rich deeply-nested graphs of event properties.
        </p><p>
			To extract information from a coarse-grained event or to perform bulk operations on the rows of the property graph in an event, Esper provides a convenient syntax: 
			When specifying a filter expression in a pattern or in a <code class="literal">select</code> clause, it may contain an contained-event selection syntax, as further described in <a class="xref" href="epl_clauses.html#epl-containedeventselect" title="5.19. Contained-Event Selection">Section 5.19, “Contained-Event Selection”</a>.
		</p></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="eventrep-insertinto"/>3.10. Event Objects Instantiated and Populated by <code class="literal">Insert Into</code></h2></div></div></div><a id="d0e3080" class="indexterm"/><p>
			For NEsper .NET also see <a class="xref" href="appendix_dotnet.html#appendix_dotnet_eventrep_insertinto" title="I.10. .NET Event Objects Instantiated and Populated by Insert Into">Section I.10, “.NET Event Objects Instantiated and Populated by Insert Into”</a>.
		</p><p>
			The <code class="literal">insert into</code> clause can instantiate and populate new instances of Java object events, <code class="literal">java.util.Map</code> events and <code class="literal">Object[]</code> (object array) events directly from the results of <code class="literal">select</code> clause expressions. Simply use the event type name as the stream name in the <code class="literal">insert into</code> clause as described in <a class="xref" href="epl_clauses.html#epl-insert-into" title="5.10. Merging Streams and Continuous Insertion: The Insert Into Clause">Section 5.10, “Merging Streams and Continuous Insertion: The Insert Into Clause”</a>.
        </p><p>
           If instead you have an existing instance of a Java object returned by an expression, such as a single-row function or static method invocation for example, you can transpose that expression result object to a stream. This is described further in <a class="xref" href="epl_clauses.html#insert-into-expression" title="5.10.7. Transposing an Expression Result">Section 5.10.7, “Transposing an Expression Result”</a> and <a class="xref" href="functionreference.html#functionreference-transpose" title="10.4. Select-Clause Transpose Function">Section 10.4, “Select-Clause Transpose Function”</a>.
        </p><p>
			The column names specified in the <code class="literal">select</code> and <code class="literal">insert into</code> clause must match available writable properties in the event object to be populated (the target event type). The expression result types of any expressions in the <code class="literal">select</code> clause must also be compatible with the property types of the target event type.
		</p><p>
			If populating a POJO-based event type and the class provides a matching constructor, the expression result types of expressions in the <code class="literal">select</code> clause must be compatible with the constructor parameters in the order listed by the constructor. The <code class="literal">insert into</code> clause column names are not relevant in this case.
		</p><p>
			Consider the following example statement:
		</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">insert into com.mycompany.NewEmployeeEvent 
select fname as firstName, lname as lastName from HRSystemEvent</pre><p>
			The above example specifies the fully-qualified class name of <code class="literal">NewEmployeeEvent</code>. The engine instantianes <code class="literal">NewEmployeeEvent</code> for each result row and populates the <code class="literal">firstName</code> and <code class="literal">lastName</code> properties of each instance from the result of <code class="literal">select</code> clause expressions. The <code class="literal">HRSystemEvent</code> in the example is assumed to have <code class="literal">lname</code> and <code class="literal">fname</code> properties, and either setter-methods and a default constructor, or a matching constructor.
		</p><p>
			Note how the example uses the <code class="literal">as</code>-keyword to assign column names that match the property names of the <code class="literal">NewEmployeeEvent</code> target event. If the property names of the source and target events are the same, the <code class="literal">as</code>-keyword is not required.
		</p><p>
			The next example is an alternate form and specifies property names within the <code class="literal">insert into</code> clause instead. The example also assumes that <code class="literal">NewEmployeeEvent</code> has been defined or imported via configuration since it does not specify the event class package name:
		</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">insert into NewEmployeeEvent(firstName, lastName) 
select fname, lname from HRSystemEvent</pre><p>
			Finally, this example populates <code class="literal">HRSystemEvent</code> events. The example populates the value of a <code class="literal">type</code> property where the event has the value 'NEW' and populates a new event object with the value 'HIRED', copying the <code class="literal">fname</code> and <code class="literal">lname</code> property values to the new event object:
		</p><pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">insert into HRSystemEvent 
select fname, lname, 'HIRED' as type from HRSystemEvent(type='NEW')</pre><p>
          The matching of the <code class="literal">select</code> or <code class="literal">insert into</code>-clause column names to target event type's property names is case-sensitive. You can specify a subset of all available columns in the target event type. Wildcard (<code class="literal">*</code>) is allowed and copies all fields of the events or multiple events in a join.
		</p><p>
			For Java object events, your event class must provide setter-methods according to JavaBean conventions or, alternatively, a matching constructor. If the event class provides setter methods the class should also provide a default constructor taking no parameters. If the event class provides a matching constructor there is no need for setter-methods. If your event class does not have a default constructor and setter methods, or a matching constructor, your application may configure a factory method via <code class="literal">ConfigurationEventTypeLegacy</code>. If your event class does not have a default constructor and there is no factory method provided, the engine uses in connection with the Oracle JVM the <code class="literal">sun.reflect.ReflectionFactory</code>, noting that in this case member variables do not get initialized to assigned defaults.
		</p><p>
			The engine follows Java standards in terms of widening, performing widening automatically in cases where widening type conversion is allowed without loss of precision, for both boxed and primitive types and including BigInteger and BigDecimal.
		</p><p>
			When inserting array-typed properties into a Java, Map-type or Object-array underlying event the event definition should declare the target property as an array.
		</p><p>
		    Please note the following limitations: 
		</p><div class="itemizedlist"><ul compact="compact"><li><p>
					Event types that utilize XML <code class="literal">org.w3c.dom.Node</code> underlying event objects cannot be target of an <code class="literal">insert into</code> clause.
				</p></li></ul></div></div></div><ul xmlns:d="http://docbook.org/ns/docbook" class="docnav"><li class="previous"><a accesskey="p" href="processingmodel.html"><strong>Prev</strong>Chapter 2. Basic Concepts</a></li><li class="up"><a accesskey="u" href="#"><strong>Top of page</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Front page</strong></a></li><li class="next"><a accesskey="n" href="context.html"><strong>Next</strong>Chapter 4. Context and Context Partitions</a></li></ul></body></html>